# rag_answer.py — SQL-first campus-wide QA (Academics + Hostel + Rules + VITREE) with FAISS fallback
import os, re, sys, argparse, sqlite3
from pathlib import Path
from typing import List, Dict, Any, Optional

# ---------------- Router for SQL answers ----------------
import sql_router as SR

# ---------------- FAISS + Gemini embeddings (fallback only) ----------------
from langchain_community.vectorstores import FAISS
from langchain_core.embeddings import Embeddings as LCEmbeddings

class GeminiLCEmbeddings(LCEmbeddings):
    def __init__(self, model: str = "models/text-embedding-004", api_key_env: str = "GEMINI_API_KEY"):
        import google.generativeai as genai
        api_key = os.getenv(api_key_env)
        if not api_key:
            # Allow running without FAISS if env not set
            raise RuntimeError("GEMINI_API_KEY not set; FAISS fallback disabled.")
        genai.configure(api_key=api_key)
        self.genai = genai
        self.model = model
    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        return [self.genai.embed_content(model=self.model, content=t)["embedding"] for t in texts]
    def embed_query(self, text: str) -> List[float]:
        return self.genai.embed_content(model=self.model, content=text)["embedding"]

def _load_store(index_dir: Path, collection: str, emb: LCEmbeddings) -> FAISS:
    return FAISS.load_local(str(index_dir), embeddings=emb, index_name=collection, allow_dangerous_deserialization=True)

def _retrieve(store: FAISS, query: str, k: int = 40):
    return store.similarity_search(query, k=k)

def _keyword_score(text: str, q: str) -> int:
    qwords = [w for w in re.findall(r"[a-z0-9]+", q.lower()) if len(w) > 2]
    t = (text or "").lower()
    return sum(t.count(w) for w in qwords)

def _rerank(docs, query: str, topn: int = 12):
    scored = []
    for d in docs:
        s = _keyword_score(d.page_content or "", query)
        scored.append((s, d))
    scored.sort(key=lambda x: x[0], reverse=True)
    return [d for s, d in scored][:topn]

def _summarize(text: str) -> str:
    blob = re.sub(r"\s+", " ", text or "").strip()
    if not blob: return ""
    parts = re.split(r"(?<=[.!?])\s+", blob)
    return " ".join(parts[:8])

def _faiss_fallback(index_dir: Path, collection: str, query: str) -> str:
    try:
        emb = GeminiLCEmbeddings()
    except Exception:
        return "_No structured match and FAISS fallback is disabled (missing GEMINI_API_KEY)._"
    store = _load_store(index_dir, collection, emb)
    docs = _retrieve(store, query, k=40)
    docs = _rerank(docs, query, topn=12)
    if not docs:
        return "_I couldn’t find enough context to answer that from your PDFs._"
    ctx, srcs = [], []
    for d in docs:
        md = d.metadata or {}
        src = md.get("source_file") or md.get("source_title") or "unknown"
        if src not in srcs and len(srcs) < 5:
            srcs.append(src)
        ctx.append(d.page_content or "")
    return f"**Answer (from your PDFs):** {_summarize(' '.join(ctx))}\n\n*Sources:* {', '.join(srcs)}"

# ---------------- small markdown helper ----------------
def _md_table(title: str, cols: List[str], rows: List[List[str]]) -> str:
    out = []
    if title: out.append(f"**{title}**")
    out.append("| " + " | ".join(cols) + " |")
    out.append("|" + "|".join(["---"]*len(cols)) + "|")
    for r in rows:
        out.append("| " + " | ".join("" if c is None else str(c) for c in r) + " |")
    return "\n".join(out)

# ---------------- reverse lookups (exact) ----------------
DB_PATH = Path("Data/sql/vit_vellore.db")
def _conn() -> Optional[sqlite3.Connection]:
    try:
        con = sqlite3.connect(str(DB_PATH))
        con.row_factory = sqlite3.Row
        return con
    except Exception:
        return None

def _looks_like_phone(s: str) -> bool:
    return bool(re.search(r"(?:\+?\d{1,3}[-\s]?)?\d{7,}", s or ""))

def _looks_like_email(s: str) -> bool:
    return "@" in (s or "") and "." in (s or "")

def _reverse_lookup_phone(con, needle: str):
    n = re.sub(r"\D", "", needle or "")
    hits=[]
    for tname in ("hostel_contacts","mh_blocks","lh_blocks"):
        cols = [c[1].lower() for c in con.execute(f"PRAGMA table_info({tname})")]
        phone_col = "phone" if "phone" in cols else ("landline" if "landline" in cols else None)
        if not phone_col: continue
        for r in con.execute(f"SELECT * FROM {tname}").fetchall():
            ph = re.sub(r'\D', '', (r[ cols.index(phone_col) ] or ""))
            if n and ph.find(n) != -1:
                if tname=="hostel_contacts":
                    hits.append(["Contact", r[cols.index('role')] if 'role' in cols else "",
                                 r[cols.index('name')] if 'name' in cols else "",
                                 r[cols.index('phone')] if 'phone' in cols else "",
                                 r[cols.index('email')] if 'email' in cols else ""])
                else:
                    code = r[cols.index('block_code')] if 'block_code' in cols else ""
                    name = r[cols.index('block_name')] if 'block_name' in cols else code
                    land = r[cols.index('landline')] if 'landline' in cols else ""
                    email= r[cols.index('email')] if 'email' in cols else ""
                    hits.append(["Block", code, name, land, email])
    return hits

def _reverse_lookup_email(con, needle: str):
    mail = (needle or "").strip().lower()
    hits=[]
    for tname in ("hostel_contacts","mh_blocks"):
        cols = [c[1].lower() for c in con.execute(f"PRAGMA table_info({tname})")]
        if "email" not in cols: continue
        for r in con.execute(f"SELECT * FROM {tname}").fetchall():
            e = (r[ cols.index("email") ] or "").lower()
            if e and e==mail:
                if tname=="hostel_contacts":
                    hits.append(["Contact", r[cols.index('role')], r[cols.index('name')], r[cols.index('phone')], r[cols.index('email')]])
                else:
                    code = r[cols.index('block_code')]
                    name = r[cols.index('block_name')] if 'block_name' in cols else code
                    land = r[cols.index('landline')] if 'landline' in cols else ""
                    hits.append(["Block", code, name, land, e])
    return hits

def _maybe_reverse_exact(q: str) -> Optional[str]:
    con = _conn()
    if not con: return None
    m = re.search(r"(\+?\d[\d\s\-]{7,})", q)
    if m and _looks_like_phone(m.group(1)):
        rows = _reverse_lookup_phone(con, m.group(1))
        if rows:
            return _md_table("Reverse lookup — phone", ["Type","Role/Code","Name","Phone","Email"], rows)
    m = re.search(r"([A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,})", q)
    if m and _looks_like_email(m.group(1)):
        rows = _reverse_lookup_email(con, m.group(1))
        if rows:
            return _md_table("Reverse lookup — email", ["Type","Role/Code","Name","Phone","Email"], rows)
    return None

# ---------------- orchestrator ----------------

def _render_sql_table(payload: Dict[str,Any]) -> str:
    tbl = payload.get("table", {})
    title = tbl.get("title","Results")
    cols  = tbl.get("columns",[])
    rows  = tbl.get("rows",[])
    # Hide Source column if present but keep compact:
    if "Source" in cols:
        si = cols.index("Source")
        cols = cols[:si] + cols[si+1:]
        rows = [[c for j,c in enumerate(r) if j!=si] for r in rows]
    return _md_table(title, cols, rows[:100])

def answer_query(index_dir: Path, collection: str, query: str) -> str:
    q = query.strip()
    if not q:
        return "_Please type a question._"

    # 1) exact hostel reverse lookups
    exact = _maybe_reverse_exact(q)
    if exact: 
        return exact

    # 2) SQL-first routing
    intent = SR.detect_structured_intent(q)
    f = SR.parse_filters(q)

    try:
        if intent == "acad_programs":
            return _render_sql_table(SR.sql_acad_programs(f))
        if intent == "acad_eligibility":
            return _render_sql_table(SR.sql_acad_eligibility(f))
        if intent == "acad_documents":
            return _render_sql_table(SR.sql_acad_documents(f))
        if intent == "acad_fees":
            return _render_sql_table(SR.sql_acad_fees(f))
        if intent == "acad_scholarships":
            return _render_sql_table(SR.sql_acad_scholarships(f))
        if intent == "rules":
            # auto categorize from query
            cat = None
            s = q.lower()
            if "attendance" in s: cat = "attendance"
            elif "refund" in s: cat = "refund"
            elif "discipline" in s: cat = "discipline"
            elif "anti ragging" in s or "anti-ragging" in s: cat = "anti-ragging"
            elif "exam" in s or "examination" in s: cat = "exam"
            f["rules_category"] = cat
            return _render_sql_table(SR.sql_rules(f))
        if intent == "vitree":
            return _render_sql_table(SR.sql_vitree(f))
        if intent == "vitree_fees":
            return _render_sql_table(SR.sql_vitree_fees(f))
        if intent == "vitree_stipend":
            return _render_sql_table(SR.sql_vitree_stipend(f))
        if intent == "hostel_contacts":
            return _render_sql_table(SR.sql_block_contacts(f))
        if intent == "hostel_blocks":
            return _render_sql_table(SR.sql_list_blocks(f))
        if intent == "hostel_tabular":
            return _render_sql_table(SR.sql_hostel_overview(f))
    except Exception:
        # fall through to FAISS
        pass

    # 3) FAISS fallback
    return _faiss_fallback(index_dir, collection, q)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--index_dir", required=True)
    ap.add_argument("--collection", default="vit_faq_vellore")
    ap.add_argument("--q", required=True)
    args = ap.parse_args()
    print("\n" + answer_query(Path(args.index_dir), args.collection, args.q) + "\n")

if __name__ == "__main__":
    main()
