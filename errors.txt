# app/handlers/academics.py
# Unified academic handlers for UG / PG / MCA / MSc
# Works with either:
#   A) unified tables with a `level` column  (level in ['UG','PG','MCA','MSC'])
#   B) split tables: ug_programs/pg_programs/...; ug_fees/pg_fees/...

from __future__ import annotations
import sqlite3
import re
from pathlib import Path
from typing import Optional, List

DB_PATH = Path("Data/sql/vit_vellore.db")

# ---------- small helpers ----------

def _connect() -> sqlite3.Connection:
    con = sqlite3.connect(str(DB_PATH))
    con.row_factory = sqlite3.Row
    return con

def _table_exists(con: sqlite3.Connection, name: str) -> bool:
    q = "SELECT 1 FROM sqlite_master WHERE type='table' AND name=?"
    return con.execute(q, (name,)).fetchone() is not None

def _md_table(title: str, cols: List[str], rows: List[List[str]]) -> str:
    if not rows:
        return "_No data found._"
    out = []
    if title:
        out.append(f"**{title}**")
    out.append("| " + " | ".join(cols) + " |")
    out.append("|" + "|".join(["---"] * len(cols)) + "|")
    for r in rows:
        out.append("| " + " | ".join("" if v is None else str(v) for v in r) + " |")
    return "\n".join(out)

def _bullets(title: str, items: List[str]) -> str:
    if not items:
        return "_No data found._"
    dedup, seen = [], set()
    for it in items:
        k = re.sub(r"\W+", "", (it or "").lower())
        if k in seen:
            continue
        seen.add(k)
        dedup.append(it)
    lines = [f"**{title}**"] + [f"- {x}" for x in dedup]
    return "\n".join(lines)

def _provenance(note: Optional[str], src: Optional[str], dt: Optional[str]) -> str:
    parts = []
    if note:
        parts.append(note)
    src_bits = []
    if src:
        src_bits.append(src)
    if dt:
        src_bits.append(f"Verified: {dt}")
    if src_bits:
        parts.append("Source: " + " · ".join(src_bits))
    return ("\n\n" + " ".join(parts)) if parts else ""

# ---------- programs ----------

def list_programs(level: str, school: Optional[str] = None) -> str:
    """
    level: 'UG' | 'PG' | 'MCA' | 'MSC'
    """
    level = level.upper()
    with _connect() as con:
        rows = []
        # unified table
        if _table_exists(con, "programs"):
            sql = "SELECT program, school, duration, campus, source_file, last_verified_on FROM programs WHERE level=?"
            args = [level]
            if school:
                sql += " AND LOWER(school)=?"
                args.append(school.lower())
            sql += " ORDER BY program"
            rs = con.execute(sql, args).fetchall()
            for r in rs:
                rows.append([r["program"], r["duration"], r["school"], r["campus"]])
            note = _provenance("Programs list.", rs[0]["source_file"] if rs else None,
                               rs[0]["last_verified_on"] if rs else None)
            return _md_table(f"{level} Programmes Offered", ["Program", "Duration", "School", "Campus"], rows) + note

        # split tables fallback
        tbl = "ug_programs" if level == "UG" else "pg_programs"
        if not _table_exists(con, tbl):
            return "_Programs table not found._"
        sql = f"SELECT program, school, duration, campus, source_file, last_verified_on FROM {tbl}"
        if school:
            sql += " WHERE LOWER(school)=?"
            rs = con.execute(sql, (school.lower(),)).fetchall()
        else:
            rs = con.execute(sql).fetchall()
        for r in rs:
            rows.append([r["program"], r["duration"], r["school"], r["campus"]])
        note = _provenance("Programs list.", rs[0]["source_file"] if rs else None,
                           rs[0]["last_verified_on"] if rs else None)
        return _md_table(f"{level} Programmes Offered", ["Program", "Duration", "School", "Campus"], rows) + note

# ---------- eligibility ----------

def eligibility(level: str, program: Optional[str] = None) -> str:
    level = level.upper()
    with _connect() as con:
        rows = []
        # unified
        if _table_exists(con, "eligibility"):
            sql = "SELECT program, criteria_text, source_file, last_verified_on FROM eligibility WHERE level=?"
            args = [level]
            if program:
                sql += " AND LOWER(program) LIKE ?"
                args.append(f"%{program.lower()}%")
            sql += " ORDER BY program"
            rs = con.execute(sql, args).fetchall()
            items = [f"{r['program']}: {r['criteria_text']}" for r in rs]
            note = _provenance("Eligibility highlights.", rs[0]["source_file"] if rs else None,
                               rs[0]["last_verified_on"] if rs else None)
            return _bullets(f"{level} Eligibility", items) + note

        # split fallback
        tbl = "ug_eligibility" if level == "UG" else "pg_eligibility"
        if not _table_exists(con, tbl):
            return "_Eligibility table not found._"
        if program:
            rs = con.execute(
                f"SELECT program, criteria_text, source_file, last_verified_on FROM {tbl} WHERE LOWER(program) LIKE ? ORDER BY program",
                (f"%{program.lower()}%",),
            ).fetchall()
        else:
            rs = con.execute(
                f"SELECT program, criteria_text, source_file, last_verified_on FROM {tbl} ORDER BY program"
            ).fetchall()
        items = [f"{r['program']}: {r['criteria_text']}" for r in rs]
        note = _provenance("Eligibility highlights.", rs[0]["source_file"] if rs else None,
                           rs[0]["last_verified_on"] if rs else None)
        return _bullets(f"{level} Eligibility", items) + note

# ---------- documents ----------

def documents(level: str) -> str:
    level = level.upper()
    with _connect() as con:
        # unified
        if _table_exists(con, "documents_required"):
            rs = con.execute(
                "SELECT item, details, source_file, last_verified_on FROM documents_required WHERE level=? ORDER BY rowid",
                (level,),
            ).fetchall()
            items = [f"{r['item']}: {r['details']}" for r in rs]
            note = _provenance("Carry originals + 2–3 photocopies.", rs[0]["source_file"] if rs else None,
                               rs[0]["last_verified_on"] if rs else None)
            return _bullets(f"{level} — Documents to Submit", items) + note

        # split fallback
        tbl = "ug_documents" if level == "UG" else "pg_documents"
        if not _table_exists(con, tbl):
            return "_Documents table not found._"
        rs = con.execute(f"SELECT item, details, source_file, last_verified_on FROM {tbl} ORDER BY rowid").fetchall()
        items = [f"{r['item']}: {r['details']}" for r in rs]
        note = _provenance("Carry originals + 2–3 photocopies.", rs[0]["source_file"] if rs else None,
                           rs[0]["last_verified_on"] if rs else None)
        return _bullets(f"{level} — Documents to Submit", items) + note

# ---------- academic fees ----------

def academic_fees(level: str,
                  program: Optional[str] = None,
                  category: Optional[str] = None,
                  year: Optional[int] = None) -> str:
    """
    category: 'Indian' | 'NRI' | 'Foreign' (case-insensitive)
    """
    level = level.upper()
    with _connect() as con:
        rows = []
        # unified
        if _table_exists(con, "academic_fees"):
            sql = ("SELECT program, category, year, tuition, one_time, caution, currency, notes, "
                   "source_file, last_verified_on FROM academic_fees WHERE level=?")
            args = [level]
            if program:
                sql += " AND LOWER(program) LIKE ?"; args.append(f"%{program.lower()}%")
            if category:
                sql += " AND LOWER(category)=?"; args.append(category.lower())
            if year:
                sql += " AND year=?"; args.append(year)
            sql += " ORDER BY program, category, year"
            rs = con.execute(sql, args).fetchall()
            for r in rs:
                rows.append([r["program"], r["category"], r["year"], r["tuition"], r["one_time"], r["caution"], r["currency"]])
            note = _provenance("Academic fee components.", rs[0]["source_file"] if rs else None,
                               rs[0]["last_verified_on"] if rs else None)
            return _md_table(f"{level} Academic Fees",
                             ["Program","Category","Year","Tuition","One-time","Caution","Curr"], rows) + note

        # split fallback
        tbl = "ug_fees" if level == "UG" else "pg_fees"
        if not _table_exists(con, tbl):
            return "_Academic fees table not found._"
        sql = f"SELECT program, category, year, tuition, one_time, caution, currency, notes, source_file, last_verified_on FROM {tbl} WHERE 1=1"
        args = []
        if program:
            sql += " AND LOWER(program) LIKE ?"; args.append(f"%{program.lower()}%")
        if category:
            sql += " AND LOWER(category)=?"; args.append(category.lower())
        if year:
            sql += " AND year=?"; args.append(year)
        sql += " ORDER BY program, category, year"
        rs = con.execute(sql, args).fetchall()
        for r in rs:
            rows.append([r["program"], r["category"], r["year"], r["tuition"], r["one_time"], r["caution"], r["currency"]])
        note = _provenance("Academic fee components.", rs[0]["source_file"] if rs else None,
                           rs[0]["last_verified_on"] if rs else None)
        return _md_table(f"{level} Academic Fees",
                         ["Program","Category","Year","Tuition","One-time","Caution","Curr"], rows) + note

# ---------- scholarships / rules ----------

def scholarships(level: Optional[str] = None) -> str:
    with _connect() as con:
        if not _table_exists(con, "scholarships"):
            return "_Scholarships table not found._"
        if level:
            rs = con.execute(
                "SELECT level, name, criteria, amount, source_file, last_verified_on FROM scholarships WHERE UPPER(level)=? ORDER BY name",
                (level.upper(),)
            ).fetchall()
        else:
            rs = con.execute(
                "SELECT level, name, criteria, amount, source_file, last_verified_on FROM scholarships ORDER BY level, name"
            ).fetchall()
        rows = [[r["level"], r["name"], r["criteria"], r["amount"]] for r in rs]
        note = _provenance("Scholarships & waivers.", rs[0]["source_file"] if rs else None,
                           rs[0]["last_verified_on"] if rs else None)
        return _md_table("Scholarships", ["Level","Name","Criteria","Amount"], rows) + note

def rules(category: Optional[str] = None) -> str:
    with _connect() as con:
        if not _table_exists(con, "rules"):
            return "_Rules table not found._"
        if category:
            rs = con.execute(
                "SELECT category, title, description, source_file, last_verified_on FROM rules WHERE LOWER(category)=? ORDER BY rowid",
                (category.lower(),)
            ).fetchall()
        else:
            rs = con.execute(
                "SELECT category, title, description, source_file, last_verified_on FROM rules ORDER BY category, rowid"
            ).fetchall()
        # collapse into bullets grouped by category
        grouped = {}
        for r in rs:
            grouped.setdefault(r["category"], []).append(f"{r['title']}: {r['description']}")
        parts = []
        any_row = rs[0] if rs else None
        for cat, items in grouped.items():
            parts.append(_bullets(f"{cat.title()} — Key Points", items))
        note = _provenance(None, any_row["source_file"] if any_row else None,
                           any_row["last_verified_on"] if any_row else None)
        return ("\n\n".join(parts) if parts else "_No data found._") + note
