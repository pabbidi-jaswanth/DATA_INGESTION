# rag_answer.py — Chat-style RAG with strong hostel routing + clean academic answers
# Works with your existing FAISS index and SQLite DB produced by load_sqlite.py

import os, re, sys, argparse, sqlite3
from pathlib import Path
from typing import List, Dict, Any, Tuple, Optional

# ---------------- FAISS + Gemini embeddings ----------------
from langchain_community.vectorstores import FAISS
from langchain_core.embeddings import Embeddings as LCEmbeddings

class GeminiLCEmbeddings(LCEmbeddings):
    def __init__(self, model: str = "models/text-embedding-004", api_key_env: str = "GEMINI_API_KEY"):
        import google.generativeai as genai
        api_key = os.getenv(api_key_env)
        if not api_key:
            print("[ERROR] GEMINI_API_KEY not set.")
            sys.exit(1)
        genai.configure(api_key=api_key)
        self.genai = genai
        self.model = model
    def embed_documents(self, texts: List[str]) -> List[List[float]]:
        return [self.genai.embed_content(model=self.model, content=t)["embedding"] for t in texts]
    def embed_query(self, text: str) -> List[float]:
        return self.genai.embed_content(model=self.model, content=text)["embedding"]

def load_store(index_dir: Path, collection: str, emb: LCEmbeddings) -> FAISS:
    return FAISS.load_local(
        str(index_dir), embeddings=emb, index_name=collection,
        allow_dangerous_deserialization=True
    )

def retrieve(store: FAISS, query: str, k: int = 40):
    return store.similarity_search(query, k=k)

def _keyword_score(text: str, q: str) -> int:
    qwords = [w for w in re.findall(r"[a-z0-9]+", q.lower()) if len(w) > 2]
    t = text.lower()
    return sum(t.count(w) for w in qwords)

def _postfilter_and_rerank(docs, query: str, want_hostel: bool = False, topn: int = 12):
    def tok(md):
        name = (md.get("source_file") or "").lower()
        return {
            "lh": "lh" in name or "ladies" in name or "girls" in name or "women" in name,
            "mh": "mh" in name or "mens" in name or "boys" in name,
            "hostel": "hostel" in name,
        }
    scored = []
    for d in docs:
        md = d.metadata or {}
        t = tok(md)
        s = 0
        if want_hostel and t["hostel"]: s += 2
        s += _keyword_score(d.page_content or "", query)
        scored.append((s, d))
    scored.sort(key=lambda x: x[0], reverse=True)
    return [d for s, d in scored][:topn]

def _faiss_context(index_dir: Path, collection: str, query: str, k: int = 20) -> Tuple[str, List[str]]:
    emb = GeminiLCEmbeddings()
    store = load_store(index_dir, collection, emb)
    docs = retrieve(store, query, k=k)
    docs = _postfilter_and_rerank(docs, query, want_hostel=True, topn=min(k, 15))
    ctx_lines, sources = [], []
    for d in docs:
        md = d.metadata or {}
        src = md.get("source_file") or md.get("source_title") or "unknown"
        sources.append(src)
        ctx_lines += [d.page_content[:1200] if d.page_content else ""]
    return "\n\n".join(ctx_lines), list(dict.fromkeys(sources))

# ---------------- SQLite helpers ----------------
DB_PATH = Path("Data/sql/vit_vellore.db")

def _conn() -> Optional[sqlite3.Connection]:
    try:
        return sqlite3.connect(str(DB_PATH))
    except Exception:
        return None

def _q(conn: sqlite3.Connection, sql: str, params: tuple = ()) -> List[sqlite3.Row]:
    conn.row_factory = sqlite3.Row
    cur = conn.execute(sql, params)
    return cur.fetchall()

# ---------------- Fallback data (from Hostel_info.pdf) ----------------
KNOWN_CONTACTS = {
    "MH": [
        ("Director", "Dr. Mohanasundaram R", "0416-220-2520", "director.mh@vit.ac.in"),
        ("Chief Warden", "Dr. Sathiavelu A", "0416-220-2521", "cw.mh@vit.ac.in"),
        ("Associate Chief Warden", "Dr. Dinesh Kumar S", "0416-220-2522", "acw.mh@vit.ac.in"),
        ("Associate Chief Warden", "Dr. Hemadri Reddy Reganti", "0416-220-2522", "acw1.mh@vit.ac.in"),
        ("Warden – Discipline", "Dr. Balamurugan J", "0416-220-2528", "warden.discipline@vit.ac.in"),
        ("Warden – Attendance", "Dr. Senthilnathan P", "0416-220-2528", "warden.attendance@vit.ac.in"),
        ("Warden – Food", "Dr. Calaivanane R", "0416-220-2528", "warden.food@vit.ac.in"),
        ("Warden – NRI & Foreign", "Dr. Viswanathan A", "0416-220-2528", "viswanathan.a@vit.ac.in"),
        ("Warden – Events", "Dr. Karthikeyan J", "0416-220-2528", "warden.events@vit.ac.in"),
        ("Administrative Officer", "Mr. Kumaravel P", "0416-220-2523", "ao.mh@vit.ac.in"),
        ("Section Supervisor (MH)", "Mr. Arasu R", "0416-220-2523", "rarasu@vit.ac.in"),
        ("Manager", "Mr. K. Ravichandran", "0416-220-2523", "manager.mh@vit.ac.in"),
        ("Assistant Manager – Food", "Mr. D. Varadharajan", "0416-220-2528", "asstmanager.food@vit.ac.in"),
        ("Assistant Manager", "Mr. Bhoobalan K", "0416-220-2526", "asstmanager1.mh@vit.ac.in"),
        ("Assistant Manager", "Mr. Chidambaram N", "0416-220-2525", "asstmanager2.mh@vit.ac.in"),
        ("Senior Supervisors (24×7)", "", "0416-220-2524", ""),
        ("Security Guard (24×7)", "", "0416-220-2527", ""),
    ],
    "LH": [
        ("Director Ladies Hostels", "Dr. Nirmala G S", "0416-220-2712", "director.lh@vit.ac.in"),
        ("Chief Warden, Ladies Hostels", "Dr. Mythili S", "0416-220-2713", "cw.lh@vit.ac.in"),
        ("Associate Chief Warden", "Dr. Jagatheswari S", "0416-220-2896", "acw.lh@vit.ac.in"),
        ("Manager", "Ms. Esther Jhansi Rani M S", "0416-220-2710 / 2711", "manager.lh1@vit.ac.in"),
        ("Assistant Manager", "Dr. K. Saranya", "0416-220-2710 / 2711", "lh.am@vit.ac.in"),
        ("Assistant Manager", "Ms. S. Dhanam", "0416-220-2710 / 2711", "lh.am1@vit.ac.in"),
        ("Section Supervisor (LH)", "Ms. G. Subbulakshmi", "0416-220-2711", "gsubbulakshmi@vit.ac.in"),
        ("Residential Block Supervisor (Transport)", "Ms. Mythily A", "9488839864, 9791297375", "mythily.a@vit.ac.in"),
    ],
}

KNOWN_MH_BLOCKS = [
    ("MH A", "Albert Einstein", "0416 220 2531", "mhablock@vit.ac.in"),
    ("MH B", "Swami Vivekananda", "0416 220 2532", "mhbblock@vit.ac.in"),
    ("MH B ANNEX", "Swami Vivekananda – B Annex", "0416 220 2533", "mhbannex@vit.ac.in"),
    ("MH C", "Rabindranath Tagore", "0416 220 2534", "mhcblock@vit.ac.in"),
    ("MH D", "Nelson Mandela", "0416 220 2535", "mhdblock@vit.ac.in"),
    ("MH D ANNEX", "Nelson Mandela – D Annex", "0416 220 2536", "mhdannex@vit.ac.in"),
    ("MH E", "Sir C.V. Raman", "0416 220 2537", "mheblock@vit.ac.in"),
    ("MH F", "Ramanujam", "0416 220 2538", "mhfblock@vit.ac.in"),
    ("MH G", "Socrates", "0416 220 2539", "mhgblock@vit.ac.in"),
    ("MH H", "John F Kennedy", "0416 220 2540", "mhhblock@vit.ac.in"),
    ("MH J", "John F Kennedy", "0416 220 2541", "mhjblock@vit.ac.in"),
    ("MH J ANNEX", "John F Kennedy – J Annex", "0416 220 2563", "mhjannexblock@vit.ac.in"),
    ("MH K", "Dr. Sarvepalli Radhakrishnan", "0416 220 2542", "mhkblock@vit.ac.in"),
    ("MH L", "Netaji Subhas Chandra Bose", "0416 220 2543", "mhlblock@vit.ac.in"),
    ("MH M", "Quaid-e-Millat Muhammed Ismail", "0416 220 2544", "mhmblock@vit.ac.in"),
    ("MH M ANNEX", "Quaid-e-Millat Muhammed Ismail – M Annex", "0416 220 2545", "mhmannexblock@vit.ac.in"),
    ("MH N", "Charles Darwin", "0416 220 2546", "mhnblock@vit.ac.in"),
    ("MH N ANNEX", "Charles Darwin – N Annex", "0416 220 2564", "mhnannexblock@vit.ac.in"),
    ("MH P", "Sardar Patel", "0416 220 2547", "mhpblock@vit.ac.in"),
    ("MH Q", "Vajpayee Block", "0416 220 2548", "mhqblock@vit.ac.in"),
    ("MH R", "Muthamizh Arignar Kalaignar M. Karunanidhi", "0416 220 2549", "mhrblock@vit.ac.in"),
    ("MH S", "Men’s Hostel S Block", "0416 220 2550", "mhsblock@vit.ac.in"),
    ("MH T", "Men’s Hostel T Block", "0416 220 2551", "mhtblock@vit.ac.in"),
]

KNOWN_LH_BLOCKS = [
    ("LH A", "LH A", "0416 220 2669", ""),
    ("LH B", "LH B", "0416 220 2670", ""),
    ("LH C", "LH C", "0416 220 2703", ""),
    ("LH D", "LH D", "0416 220 2703", ""),
    ("LH E", "LH E", "0416 220 2705", ""),
    ("LH F", "LH F", "0416 220 2706", ""),
    ("LH G", "LH G", "0416 220 2892", ""),
    ("LH H", "LH H", "0416 220 2894", ""),
    ("LH J", "LH J", "0416 220 2896", ""),
    ("RGT H", "RGT H", "0416 220 5003", ""),
    ("LH GH (ANNEX)", "LH GH (ANNEX)", "0416 220 2244", ""),
]

# ---------------- Text utils ----------------
def _norm(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

def _looks_like_phone(s: str) -> bool:
    return bool(re.search(r"(?:\+?\d{1,3}[-\s]?)?\d{3,}[-\s]?\d{3,}", s or ""))

def _looks_like_email(s: str) -> bool:
    return "@" in (s or "") and "." in (s or "")

# ---------------- Formatters ----------------
def md_table(title: str, cols: List[str], rows: List[List[str]]) -> str:
    # dedupe rows
    seen=set(); uniq=[]
    for r in rows:
        tup=tuple(r)
        if tup in seen: continue
        seen.add(tup); uniq.append(r)
    out = []
    if title: out.append(f"**{title}**")
    out.append("| " + " | ".join(cols) + " |")
    out.append("|" + "|".join(["---"]*len(cols)) + "|")
    for r in uniq:
        out.append("| " + " | ".join("" if c is None else str(c) for c in r) + " |")
    return "\n".join(out)

def bullets(lines: List[str], title: Optional[str]=None) -> str:
    if not lines: return ""
    # dedupe but preserve order
    seen=set(); out_lines=[]
    for ln in lines:
        if ln in seen: continue
        seen.add(ln); out_lines.append(ln)
    out = [f"**{title}**" if title else ""]
    out += [f"- {ln}" for ln in out_lines]
    return "\n".join([x for x in out if x])

# ---------------- Hostel: DB fetchers (merge DB + fallback) ----------------
def _get_mh_blocks(conn) -> List[Tuple[str,str,str,str]]:
    by_key = {}
    for code, name, land, email in KNOWN_MH_BLOCKS:
        by_key[_norm(code)] = (code, name, land, email)
    try:
        rows = _q(conn, "SELECT block_code, COALESCE(block_name, block_code) AS block_name, landline, COALESCE(email,'') as email FROM mh_blocks")
        for r in rows:
            by_key[_norm(r["block_code"])] = (r["block_code"], r["block_name"], r["landline"], r["email"])
    except Exception:
        pass
    # sorted by block code alpha
    return sorted(by_key.values(), key=lambda x: _norm(x[0]))

def _get_lh_blocks(conn) -> List[Tuple[str,str,str,str]]:
    by_key = {}
    for code, name, land, email in KNOWN_LH_BLOCKS:
        by_key[_norm(code)] = (code, name, land, email)
    try:
        rows = _q(conn, "SELECT block_code, block_code AS block_name, landline, '' as email FROM lh_blocks")
        for r in rows:
            by_key[_norm(r["block_code"])] = (r["block_code"], r["block_code"], r["landline"], "")
    except Exception:
        pass
    return sorted(by_key.values(), key=lambda x: _norm(x[0]))

def _get_contacts(conn, gender: str) -> List[Tuple[str,str,str,str]]:
    # Merge DB rows (if any) with rich fallback so filters never go empty
    merged = []
    try:
        # pull everything; don't overfilter here
        rows = _q(conn, "SELECT role, name, phone, email FROM hostel_contacts")
        for r in rows:
            merged.append((r["role"] or "", r["name"] or "", r["phone"] or "", r["email"] or ""))
    except Exception:
        pass
    merged += KNOWN_CONTACTS.get(gender, [])
    # de-dup by (role,name,phone,email)
    seen=set(); out=[]
    for t in merged:
        if t in seen: continue
        seen.add(t); out.append(t)
    return out

# Reverse lookups across both contacts and blocks
def _reverse_lookup_phone(conn, needle: str) -> List[Tuple[str,str,str,str,str]]:
    n = re.sub(r"\D", "", needle or "")
    hits = []
    for g in ("MH","LH"):
        for role, name, phone, email in _get_contacts(conn, g):
            ph_norm = re.sub(r"\D","", phone or "")
            if n and ph_norm.find(n) != -1:
                hits.append(("Contact", g, role, name or "-", phone, email or ""))
    for code, name, land, email in _get_mh_blocks(conn):
        ph_norm = re.sub(r"\D","", land or "")
        if n and ph_norm.find(n) != -1:
            hits.append(("Block", "MH", code, name, land, email or ""))
    for code, name, land, email in _get_lh_blocks(conn):
        ph_norm = re.sub(r"\D","", land or "")
        if n and ph_norm.find(n) != -1:
            hits.append(("Block", "LH", code, name, land, email or ""))
    return hits

def _reverse_lookup_email(conn, needle: str) -> List[Tuple[str,str,str,str,str]]:
    mail = (needle or "").strip().lower()
    hits = []
    for g in ("MH","LH"):
        for role, name, phone, email in _get_contacts(conn, g):
            if email and email.lower() == mail:
                hits.append(("Contact", g, role, name or "-", phone or "", email))
    for code, name, land, email in _get_mh_blocks(conn):
        if email and email.lower() == mail:
            hits.append(("Block", "MH", code, name, land or "", email))
    return hits

# Block code/name search
def _find_block(conn, text: str, gender_hint: Optional[str]) -> List[Tuple[str,str,str,str,str]]:
    t = _norm(text)
    out = []
    for code, name, land, email in _get_mh_blocks(conn):
        if gender_hint and gender_hint!="MH": break
        if t in _norm(code) or _norm(name).find(t) != -1:
            out.append(("MH", code, name, land, email))
    for code, name, land, email in _get_lh_blocks(conn):
        if gender_hint and gender_hint!="LH": break
        if t in _norm(code) or _norm(name).find(t) != -1:
            out.append(("LH", code, name, land, email))
    return out

# ---------------- Intent detection ----------------
def detect_hostel_intent(q: str) -> Dict[str, Any]:
    qq = q.lower()

    # hostel context?
    hostelish = any(w in qq for w in ["hostel","block","mh","lh","boys","girls","mens","ladies","warden","supervisor","director","manager","landline"])
    g = None
    if any(w in qq for w in ["men", "boys", "mh", "mens"]): g = "MH"
    if any(w in qq for w in ["ladies", "girls", "women", "lh"]): g = "LH" if g is None else g

    wants_landlines = hostelish and any(w in qq for w in ["landline", "land line", "std", "phone number", "contact number", "phone", "call"])
    # contacts only if hostel context OR explicit role keyword
    role_hit = any(w in qq for w in ["director","directo","chief warden","associate chief","warden","manager","assistant manager","section supervisor","supervisor","discipline","attendance","events","food"])
    wants_contacts  = hostelish and role_hit or role_hit

    wants_blocks    = hostelish and "block" in qq and any(w in qq for w in ["name","names","code","codes","list"])

    # capture block code like MHJ / MH J / LHA etc
    specific_block  = None
    m = re.search(r"\b(MH|LH)\s*-?\s*([A-Z]{1,2})(?:\s*ANNEX)?\b", q, re.I)
    if m:
        specific_block = (m.group(1).upper() + " " + m.group(2).upper()).strip()
        if "annex" in qq: specific_block += " ANNEX"

    famous = None
    for name in ["john f kennedy","kennedy","albert einstein","swami vivekananda","nelson mandela","quaid","darwin","vajpayee","radhakrishnan","netaji","sardar patel","socrates","c.v.raman","ramanujam","karunanidhi"]:
        if name in qq:
            famous = name
            break

    reverse_phone = None
    m = re.search(r"(\+?\d[\d\s\-]{7,})", q)
    if m and _looks_like_phone(m.group(1)): reverse_phone = m.group(1)

    reverse_mail = None
    m = re.search(r"([A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,})", q)
    if m and _looks_like_email(m.group(1)): reverse_mail = m.group(1)

    return {
        "hostelish": hostelish, "gender": g,
        "landlines": wants_landlines, "contacts": wants_contacts,
        "blocks": wants_blocks, "specific_block": specific_block,
        "famous": famous, "reverse_phone": reverse_phone, "reverse_mail": reverse_mail
    }

# ---------------- Hostel renderers ----------------
def render_mh_landlines(conn) -> str:
    rows = _get_mh_blocks(conn)
    return md_table("Men’s Hostel — Block-wise Landlines", ["Block Code","Block Name","Landline","Email"], rows)

def render_lh_landlines(conn) -> str:
    rows = _get_lh_blocks(conn)
    return md_table("Ladies’ Hostel — Block-wise Landlines", ["Block Code","Block Name","Landline","Email"], rows)

def render_block_list(conn, g: Optional[str]) -> str:
    mh = _get_mh_blocks(conn) if (g in (None,"MH")) else []
    lh = _get_lh_blocks(conn) if (g in (None,"LH")) else []
    lines = []
    if g in (None,"MH"):
        lines += [f"{code} — {name}" for code,name,_,_ in mh]
    if g in (None,"LH"):
        lines += [f"{code} — {name}" for code,name,_,_ in lh]
    title = "Hostel Blocks" if g is None else ("Men’s Hostel Blocks" if g=="MH" else "Ladies’ Hostel Blocks")
    return bullets(lines, title)

def render_block_info(conn, text: str, g: Optional[str]) -> str:
    hits = _find_block(conn, text, g)
    if not hits:
        return "_No matching block found._"
    rows = []
    for gender, code, name, land, email in hits:
        rows.append([gender, code, name, land, email or ""])
    return md_table("Block Details", ["Hostel","Block Code","Block Name","Landline","Email"], rows)

def render_contacts(conn, g: str, role_filter: Optional[str]=None) -> str:
    rows = _get_contacts(conn, g)
    # If a role filter is provided, keep only matching; if empty, fall back to full KNOWN set
    if role_filter:
        rnorm = _norm(role_filter)
        filtered = [r for r in rows if _norm(r[0]).find(rnorm)!=-1]
        rows = filtered if filtered else KNOWN_CONTACTS.get(g, [])
    if not rows:
        return "_No contacts available._"
    show = []
    for role, name, phone, email in rows:
        who = f"{role}: {name}" if name else role
        bits = []
        if phone: bits.append(phone)
        if email: bits.append(email)
        show.append(f"{who} — " + " | ".join(bits) if bits else who)
    title = "Men’s Hostel — Key Contacts" if g=="MH" else "Ladies’ Hostel — Key Contacts"
    return bullets(show, title)

def render_reverse_phone(conn, phone: str) -> str:
    hits = _reverse_lookup_phone(conn, phone)
    if not hits:
        return "_No matches for that phone number._"
    rows = []
    for kind, g, a, b, c, d in hits:
        if kind=="Contact":
            rows.append([g, "Contact", a, b, c, d])
        else:
            rows.append([g, "Block", a, b, c, d])
    return md_table("Reverse lookup — phone", ["Hostel","Type","Role/Code","Name","Phone","Email"], rows)

def render_reverse_mail(conn, mail: str) -> str:
    hits = _reverse_lookup_email(conn, mail)
    if not hits:
        return "_No matches for that email._"
    rows = []
    for kind, g, a, b, c, d in hits:
        if kind=="Contact":
            rows.append([g, "Contact", a, b, c, d])
        else:
            rows.append([g, "Block", a, b, c, d])
    return md_table("Reverse lookup — email", ["Hostel","Type","Role/Code","Name","Phone","Email"], rows)

# ---------------- Academic extractors (programs, documents, etc.) ----------------
def _extract_lines(text: str) -> List[str]:
    text = re.sub(r"[ \t]+", " ", text or "")
    raw = re.split(r"[\r\n]+", text)
    lines = []
    for ln in raw:
        ln = ln.strip(" -•\u2022\t")
        if not ln: continue
        lines.append(ln)
    return lines

def summarize_programs(text: str) -> List[str]:
    lines = _extract_lines(text)
    picks = []
    pat = re.compile(r"\b(B\.?Tech|B\.?Sc|B\.?Com|B\.?A|BBA|BCA|Integrated|Dual|Honours?)\b", re.I)
    for ln in lines:
        if pat.search(ln):
            # keep short program-looking lines
            if len(ln) <= 140:
                picks.append(ln)
    # dedupe and keep first ~20
    seen=set(); out=[]
    for ln in picks:
        k=_norm(ln)
        if k in seen: continue
        seen.add(k); out.append(ln)
        if len(out)>=20: break
    return out

def summarize_documents(text: str) -> List[str]:
    lines = _extract_lines(text)
    picks=[]
    keys = ["class 12","xii","hsc","10","sslc","marksheet","mark statement","transfer certificate","tc","migration","provisional","aadhaar","aadhar","pan","passport","visa","id proof","photo","nativity","community","caste","bonafide","medical","blood","undertaking","anti ragging"]
    for ln in lines:
        ln_low = ln.lower()
        if any(k in ln_low for k in keys):
            # compact
            ln = re.sub(r"\s{2,}"," ", ln)
            if len(ln) <= 160:
                picks.append(ln)
    # tidy itemize
    clean=[]
    for ln in picks:
        ln = re.sub(r"^\d+\)\s*|\d+\.\s*|[-•]\s*", "", ln).strip()
        clean.append(ln)
    # dedupe
    seen=set(); out=[]
    for ln in clean:
        k=_norm(ln)
        if k in seen: continue
        seen.add(k); out.append(ln)
        if len(out)>=20: break
    return out

def summarize_generic(text: str) -> str:
    # first ~8 sentences; compact whitespace
    blob = re.sub(r"\s+", " ", text or "").strip()
    if not blob: return ""
    parts = re.split(r"(?<=[.!?])\s+", blob)
    return " ".join(parts[:8])

# ---------------- Main orchestrator ----------------
def answer_query(index_dir: Path, collection: str, query: str) -> str:
    intent = detect_hostel_intent(query)
    conn = _conn()

    # 1) HIGH-PRIORITY HOSTEL ROUTES
    if intent["reverse_phone"]:
        return render_reverse_phone(conn, intent["reverse_phone"])
    if intent["reverse_mail"]:
        return render_reverse_mail(conn, intent["reverse_mail"])

    if intent["landlines"]:
        if intent["gender"] in (None, "MH"):
            out = render_mh_landlines(conn)
            if intent["gender"] is None:
                out += "\n\n" + render_lh_landlines(conn)
            return out
        if intent["gender"] == "LH":
            return render_lh_landlines(conn)

    if intent["blocks"]:
        return render_block_list(conn, intent["gender"])

    if intent["specific_block"] or intent["famous"]:
        key = intent["specific_block"] or intent["famous"]
        return render_block_info(conn, key, intent["gender"])

    if intent["contacts"]:
        g = intent["gender"] or "MH"  # default MH
        role_words = [
            "director","chief warden","associate chief warden","warden",
            "discipline","attendance","events","food","manager",
            "assistant manager","section supervisor","supervisor",
        ]
        filt = None
        qlow = query.lower()
        for w in role_words:
            if w in qlow: filt = w; break
        # name-based ask (e.g., "nirmala mam")
        name_match = re.search(r"(dr\.|mr\.|ms\.)?\s*([A-Za-z][A-Za-z\s\.]{2,})", query, re.I)
        name_phrase = name_match.group(0).strip() if name_match else None
        ans = render_contacts(conn, g, role_filter=filt)
        if name_phrase:
            nm = _norm(name_phrase)
            lines = [ln for ln in ans.split("\n") if nm in _norm(ln)]
            if lines:
                return bullets(lines, "Requested contact")
        return ans

    # 2) ACADEMIC / GENERAL QUERIES (programs, docs, scholarships, rules…)
    emb = GeminiLCEmbeddings()
    store = load_store(index_dir, collection, emb)
    docs = retrieve(store, query, k=40)
    want_hostel_bias = intent["hostelish"]
    docs = _postfilter_and_rerank(docs, query, want_hostel=want_hostel_bias, topn=12)

    ctx_lines, sources = [], []
    for d in docs:
        md = d.metadata or {}
        src = md.get("source_file") or md.get("source_title") or "unknown"
        sources.append(src)
        ctx_lines += [d.page_content or ""]
    text = "\n\n".join(ctx_lines)
    if not text.strip():
        return "_I couldn’t find enough context to answer that from your PDFs._"

    ql = query.lower()

    # Programs offered (UG)
    if ("program" in ql or "programme" in ql) and any(w in ql for w in ["ug","undergrad","btech","b.tech","b sc","bsc","bca","bba"]):
        items = summarize_programs(text)
        if items:
            return bullets(items, "UG Programmes Offered") + f"\n\n*Sources:* " + ", ".join(list(dict.fromkeys(sources))[:5])
        # fallback to generic summary
        para = summarize_generic(text)
        return f"**Answer:** {para}\n\n*Sources:* " + ", ".join(list(dict.fromkeys(sources))[:5])

    # Documents to submit (UG)
    if "document" in ql or "submit" in ql or "submission" in ql:
        items = summarize_documents(text)
        if items:
            return bullets(items, "Documents to submit (UG)") + f"\n\n*Tip:* Carry originals + 2–3 photocopies.\n*Sources:* " + ", ".join(list(dict.fromkeys(sources))[:5])
        para = summarize_generic(text)
        return f"**Answer:** {para}\n\n*Sources:* " + ", ".join(list(dict.fromkeys(sources))[:5])

    # Scholarships or fees (non-hostel)
    if "scholar" in ql or ("fee" in ql and "hostel" not in ql):
        para = summarize_generic(text)
        return f"**Answer:** {para}\n\n*Sources:* " + ", ".join(list(dict.fromkeys(sources))[:5])

    # 3) ONLY IF the user explicitly mentions hostel with fee tables, use SQL router
    if intent["hostelish"] and ("fee" in ql or "mess" in ql):
        try:
            import sql_router as SR
            sr_intent = SR.detect_structured_intent(query)
            f = SR.parse_filters(query)
            if sr_intent in ("tabular", "contacts", "blocks"):
                if sr_intent == "contacts":
                    data = SR.sql_block_contacts(f)
                elif sr_intent == "blocks":
                    data = SR.sql_list_blocks(f)
                else:
                    data = SR.sql_hostel_overview(f)

                cols = data["table"]["columns"][:]
                rows = [r[:] for r in data["table"]["rows"]]
                if "Source" in cols:
                    si = cols.index("Source")
                    cols = cols[:si] + cols[si+1:]
                    rows = [[c for j,c in enumerate(r) if j!=si] for r in rows]
                seen=set(); clean=[]
                for r in rows:
                    key = tuple("" if c is None else str(c).strip() for c in r)
                    if key in seen: continue
                    seen.add(key); clean.append(r)
                return md_table(data["table"].get("title","Results"), cols, clean[:60]) + \
                       "\n\n*Note: Structured answers come from your SQLite DB built from official PDFs.*"
        except Exception:
            pass

    # 4) Generic fallback summary
    para = summarize_generic(text)
    srcs = ", ".join(list(dict.fromkeys(sources))[:5])
    return f"**Answer (from your PDFs):** {para}\n\n*Sources:* {srcs}\n*Note: Answers are grounded in your ingested PDFs.*"

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--index_dir", required=True)
    ap.add_argument("--collection", default="vit_faq_vellore")
    ap.add_argument("--emb", choices=["gemini"], default="gemini")
    ap.add_argument("--q", required=True)
    args = ap.parse_args()
    print("\n" + answer_query(Path(args.index_dir), args.collection, args.q) + "\n")

if __name__ == "__main__":
    main()
