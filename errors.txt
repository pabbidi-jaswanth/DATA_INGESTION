# rag_answer.py â€” Router-first RAG with SQL handlers for Academics, Hostels, VITREE, Rules
# Uses FAISS+Gemini only as a fallback for unstructured asks.
# Expect DB at Data/sql/vit_vellore.db and FAISS index at Data/index/faiss.

import os, re, argparse
from pathlib import Path

# ---------------- Handlers & utils ----------------
# (kept in a try/except so the CLI prints a helpful error if a module is missing)
try:
    from app.handlers import academics as A
    from app.handlers import hostels as H
    from app.handlers import vitree as V
    from app.handlers import rules as R
    from app.utils.aliases import detect_gender, detect_category, detect_level, detect_year
    from app.utils.fallback_rag import rag_fallback
except Exception as e:
    print("[IMPORT ERROR] Make sure app/handlers/* and app/utils/* files exist and are importable.")
    print(str(e))

# ---------------- Intent detection ----------------
ROLE_WORDS = [
    "director","chief warden","associate chief warden","warden",
    "discipline","attendance","events","food","manager",
    "assistant manager","section supervisor","supervisor","helpdesk","office","transport","nri","foreign"
]

def _has_any(q: str, words) -> bool:
    s = q.lower()
    return any(w in s for w in words)

def detect_intent(q: str) -> str:
    s = q.lower()

    # hard signals first
    if re.search(r"[A-Za-z0-9._%+\-]+@[A-Za-z0-9.\-]+\.[A-Za-z]{2,}", s) or re.search(r"(?:\+?\d{1,3}[-\s]?)?\d{6,}", s):
        return "hostel.reverse"

    if "landline" in s or ("block wise" in s and ("number" in s or "phone" in s)):
        return "hostel.landlines"

    if "block" in s and _has_any(s, ["info","detail","code","name","mh","lh"]) or re.search(r"\b(?:MH|LH)\s*[A-Z]{1,2}(?:\s*ANNEX)?\b", s):
        return "hostel.block.detail"

    if "hostel" in s and _has_any(s, ROLE_WORDS):
        return "hostel.contacts"

    # hostel fees only when clearly asked
    if "hostel" in s and _has_any(s, ["fee","fees","mess"]):
        return "hostel.fees"

    # academics: programs / eligibility / documents / fees
    if _has_any(s, ["program","programme","courses","course list"]):
        if _has_any(s, ["ug","undergrad","btech","b.tech","bca","bba","bsc","b.sc"]): return "programs.ug.list"
        if _has_any(s, ["pg","postgrad","mtech","m.tech","mca","msc","m.sc","mba"]):   return "programs.pg.list"
        return "programs.any.list"

    if _has_any(s, ["eligibility","eligible","criteria","qualification","min marks"]):
        if "mca" in s: return "eligibility.mca"
        if _has_any(s, ["msc","m.sc"]): return "eligibility.msc"
        if _has_any(s, ["pg","postgrad","mtech","m.tech","mba"]): return "eligibility.pg"
        return "eligibility.ug"

    if _has_any(s, ["document","documents","certificate","submit","submission","upload"]):
        if _has_any(s, ["pg","mtech","m.tech","mca","msc","m.sc","postgrad"]): return "documents.pg"
        return "documents.ug"

    if "fee" in s or "tuition" in s:
        # NOT hostel; academic fees
        if _has_any(s, ["pg","postgrad","mtech","m.tech","mca","msc","m.sc","mba"]): return "fees.academic.pg"
        return "fees.academic.ug"

    # rules / norms
    if _has_any(s, ["refund","withdrawal","caution deposit"]): return "rules.refund"
    if _has_any(s, ["attendance","shortage"]):                  return "rules.attendance"
    if _has_any(s, ["discipline","code of conduct","late entry","curfew"]): return "rules.discipline"
    if _has_any(s, ["anti ragging","antiragging","ragging"]):  return "rules.antiragging"
    if _has_any(s, ["rules","norms","policy","policies"]):     return "rules.general"

    # VITREE / research
    if "vitree" in s or "phd" in s:
        if "fee" in s or "fees" in s: return "vitree.fees"
        if _has_any(s, ["stipend","scholarship","fellowship","salary"]): return "vitree.stipend"
        return "vitree.process"

    # FAQs / general
    if "faq" in s: return "faqs.general"

    return "open"  # let fallback RAG try
# ---------------- Small helpers for slot filling ----------------
def _role_hint(q: str):
    s = q.lower()
    for w in ROLE_WORDS:
        if w in s: return w
    return None

def _program_hint(q: str):
    s = q.lower()
    # very light program extraction
    m = re.search(r"(computer science|cse|it|information technology|ai|data science|cyber|ece|eee|mechanical|civil|biotech|mca|mba|msc|m\.sc|mtech|m\.tech|bca|bba|bsc|b\.sc)", s)
    return m.group(1) if m else None

# ---------------- Main orchestrator ----------------
def answer_query(index_dir: Path, collection: str, query: str) -> str:
    intent = detect_intent(query)

    # shared slots
    gender   = detect_gender(query)          # 'Boys' / 'Girls' / None
    category = detect_category(query)        # 'Indian' / 'NRI' / None
    level    = detect_level(query)           # 'First-Year' / 'Senior' / None
    year     = detect_year(query)            # int or None
    role     = _role_hint(query)
    prog     = _program_hint(query)

    # ---------- HOSTELS ----------
    if intent == "hostel.reverse":
        return H.reverse_lookup(query)

    if intent == "hostel.landlines":
        return H.landlines(gender)

    if intent == "hostel.block.detail":
        return H.block_detail(query, gender)

    if intent == "hostel.contacts":
        return H.contacts(gender or "Boys", role_filter=role)

    if intent == "hostel.fees":
        return H.hostel_fees(
            gender=gender,
            level=level,
            category=category,
            year=year,
            block_type=None  # add mapping if you parse "deluxe/apartment/regular" from query
        )

    # ---------- ACADEMICS ----------
    if intent == "programs.ug.list":
        return A.list_programs("UG")

    if intent == "programs.pg.list":
        # you can split further into MCA/MSC lists if you keep those as separate level values
        return A.list_programs("PG")

    if intent == "programs.any.list":
        # default to UG list + hint to ask for PG
        out = A.list_programs("UG")
        more = A.list_programs("PG")
        return out + ("\n\n" + more if more and "No data" not in more else "")

    if intent == "eligibility.ug":
        return A.eligibility("UG", program_hint=prog)

    if intent == "eligibility.pg":
        return A.eligibility("PG", program_hint=prog)

    if intent == "eligibility.mca":
        return A.eligibility("MCA", program_hint=prog or "MCA")

    if intent == "eligibility.msc":
        return A.eligibility("MSC", program_hint=prog or "M.Sc")

    if intent == "documents.ug":
        return A.documents("UG")

    if intent == "documents.pg":
        return A.documents("PG")

    if intent == "fees.academic.ug":
        return A.academic_fees("UG", program_hint=prog, category=category, year=year)

    if intent == "fees.academic.pg":
        return A.academic_fees("PG", program_hint=prog, category=category, year=year)

    # ---------- RULES ----------
    if intent == "rules.refund":
        return R.refund()

    if intent == "rules.attendance":
        return R.attendance()

    if intent == "rules.discipline":
        return R.discipline()

    if intent == "rules.antiragging":
        return R.anti_ragging()

    if intent == "rules.general":
        return R.rules()

    # ---------- VITREE ----------
    if intent == "vitree.process":
        return V.process()

    if intent == "vitree.fees":
        return V.fees(year=year, category=category)

    if intent == "vitree.stipend":
        return V.stipend()

    # ---------- FAQs / OPEN / FALLBACK ----------
    # If none of the SQL handlers fired, fall back to vector search with clean summarization.
    return rag_fallback(index_dir, collection, query, want_hostel_bias=("hostel" in query.lower()))

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--index_dir", required=True)
    ap.add_argument("--collection", default="vit_faq_vellore")
    ap.add_argument("--q", required=True)
    args = ap.parse_args()
    print("\n" + answer_query(Path(args.index_dir), args.collection, args.q) + "\n")

if __name__ == "__main__":
    main()
