# fix_router_and_test.py  â€” put this in project root and run with python
import os, pathlib, sqlite3, textwrap, sys

ROOT = pathlib.Path(__file__).resolve().parent
APP  = ROOT / "app"
HAND = APP / "handlers"
UTIL = APP / "utils"
DB   = ROOT / "Data" / "sql" / "vit_vellore.db"

for p in [APP, HAND, UTIL]:
    p.mkdir(parents=True, exist_ok=True)
    (p / "__init__.py").write_text("", encoding="utf-8")

sql_router_code = r"""
import sqlite3, pathlib, re
from typing import Dict, Any, List

DB = pathlib.Path('Data/sql/vit_vellore.db')

ACA_KEYWORDS = {
    'programs': ['program','course','degree','b.tech','m.tech','mca','msc','programme'],
    'eligibility': ['eligibility','qualify','criteria','requirements','min marks'],
    'documents': ['document','documents','docs','upload','certificate','proof','bonafide'],
    'fees': ['tuition','fee','fees','academic fee','semester fee'],
    'scholarships': ['scholarship','waiver','merit','financial aid']
}

def detect_structured_intent(q: str) -> str:
    ql = q.lower()
    if any(k in ql for k in ['contact','phone','email','supervisor','warden','director','manager']):
        return 'contacts'
    if 'block' in ql and any(k in ql for k in ['name','names','list','all','codes','code']):
        return 'blocks'
    if any(k in ql for k in ['hostel','room','mess','laundry','mh','lh']):
        return 'hostel'
    for tag, words in ACA_KEYWORDS.items():
        if any(w in ql for w in words):
            return tag
    if any(k in ql for k in ['fee','fees','tuition']):
        return 'fees'
    return 'text'

def parse_filters(q: str) -> Dict[str, Any]:
    ql = q.lower()
    f = {'ay': None, 'gender': None, 'category': None, 'level': None, 'program_like': None, 'level_like': None}
    m = re.search(r'\\b(20\\d{2})\\b', ql)
    if m:
        yr = m.group(1); f['ay'] = f'{yr}-{str(int(yr[-2:])+1).zfill(2)}'
    if any(k in ql for k in ['boy','boys','men','mh','mens']): f['gender'] = 'Male'
    if any(k in ql for k in ['girl','girls','ladies','lh','women']): f['gender'] = 'Female'
    if 'nri' in ql: f['category'] = 'NRI'
    elif 'foreign' in ql: f['category'] = 'Foreign'
    elif 'indian' in ql: f['category'] = 'Indian'
    if 'senior' in ql: f['level'] = 'Senior'
    if 'first year' in ql or 'fresh' in ql: f['level'] = 'First-Year'
    m = re.search(r'\\b(b\\.?tech|m\\.?tech|mca|msc|cse|ece|mechanical|biotech|ai|data)\\b', ql)
    if m: f['program_like'] = m.group(1).replace('.','')
    if 'ug' in ql: f['level_like'] = 'UG'
    if 'pg' in ql: f['level_like'] = 'PG'
    return f

def _mk():
    con = sqlite3.connect(DB)
    con.row_factory = sqlite3.Row
    return con

def _safe_fetch(con, sql, args) -> List[sqlite3.Row]:
    try: return con.execute(sql, args).fetchall()
    except sqlite3.OperationalError: return []

# -------- HOSTEL --------
def sql_hostel_overview(f: Dict[str,Any], limit_rows: int = 800) -> Dict[str, Any]:
    con = _mk()
    where = ['1=1']; args=[]
    if f['gender']:   where.append('IFNULL(b.gender,\"\")=IFNULL(?, \"\")');   args.append(f['gender'])
    if f['level']:    where.append('IFNULL(b.level,\"\")=IFNULL(?, \"\")');    args.append(f['level'])
    if f['ay']:       where.append('IFNULL(hf.ay,\"\")=IFNULL(?, \"\")');      args.append(f['ay'])
    if f['category']: where.append('IFNULL(hf.category,\"\")=IFNULL(?, \"\")');args.append(f['category'])
    where.append(\"\"\"(
        COALESCE(hf.total_fee,'')<>'' OR COALESCE(hf.room_mess_fee,'')<>'' OR
        COALESCE(hf.admission_fee,'')<>'' OR COALESCE(hf.caution_deposit,'')<>'' OR
        COALESCE(hf.occupancy,'')<>'' OR COALESCE(hf.mess_type,'')<>''
    )\"\"\")
    sql = f\"\"\"
    SELECT b.display_name AS block, b.gender, b.level, b.block_type,
           hf.ay, hf.category, hf.occupancy, hf.ac, hf.mess_type,
           hf.room_mess_fee, hf.admission_fee, hf.caution_deposit, hf.other_fee, hf.total_fee, hf.currency,
           hf.source_file
    FROM hostel_fees hf
    JOIN blocks b ON b.id = hf.block_id
    WHERE {' AND '.join(where)}
    ORDER BY b.block_type, block, hf.occupancy, hf.ac DESC, hf.mess_type
    \"\"\"
    rows = _safe_fetch(con, sql, args); con.close()
    columns = ['Block','Gender','Level','Type','AY','Category','Occ','AC','Mess',
               'Room+Mess','Admission','Caution','Other','Total','Curr','Source']
    tbl = {'title':'Hostel Fee Details (Vellore)', 'columns':columns, 'rows':[]}
    for r in rows[:limit_rows]:
        tbl['rows'].append([
            r['block'] or '', r['gender'] or '', r['level'] or '', r['block_type'] or '',
            r['ay'] or '', r['category'] or '', r['occupancy'] or '',
            'AC' if (r['ac']==1) else ('Non-AC' if (r['ac']==0) else ''),
            r['mess_type'] or '', r['room_mess_fee'] or '', r['admission_fee'] or '',
            r['caution_deposit'] or '', r['other_fee'] or '', r['total_fee'] or '',
            r['currency'] or '', r['source_file'] or ''
        ])
    return {'table': tbl, 'bullets': []}

def sql_block_contacts(_f: Dict[str,Any]) -> Dict[str,Any]:
    con = _mk()
    rows = _safe_fetch(con, \"
        SELECT '' AS block, name, role, phone, email
        FROM hostel_contacts
        ORDER BY role, name
    \", [])
    con.close()
    cols = ['Block','Name','Role','Phone','Email']
    tbl = {'title':'Hostel Contacts', 'columns':cols, 'rows':[
        [r['block'], r['name'] or '', r['role'] or '', r['phone'] or '', r['email'] or '']
        for r in rows
    ]}
    return {'table': tbl, 'bullets': []}

def sql_list_blocks(f: Dict[str,Any]) -> Dict[str,Any]:
    con = _mk()
    if f['gender'] == 'Female':
        sql = \"SELECT block_code AS display_name, 'Female' AS gender FROM lh_blocks ORDER BY block_code\"
    elif f['gender'] == 'Male':
        sql = \"SELECT COALESCE(block_name, block_code) AS display_name, 'Male' AS gender FROM mh_blocks ORDER BY block_code\"
    else:
        sql = \"
        SELECT COALESCE(block_name, block_code) AS display_name, 'Male' AS gender FROM mh_blocks
        UNION ALL
        SELECT block_code AS display_name, 'Female' AS gender FROM lh_blocks
        ORDER BY gender, display_name
        \"
    rows = _safe_fetch(con, sql, []); con.close()
    cols = ['Block','Gender']
    tbl = {'title':'Hostel Blocks', 'columns':cols, 'rows':[
        [r['display_name'] or '', r['gender'] or ''] for r in rows
    ]}
    return {'table': tbl, 'bullets': []}

# -------- ACADEMICS --------
def _like_clause(col: str, val: str, wh: list, args: list):
    if val:
        wh.append(f'LOWER({col}) LIKE ?')
        args.append(f'%{val.lower()}%')

def sql_programs(f: Dict[str,Any], q: str) -> Dict[str,Any]:
    con = _mk()
    where, args = ['1=1'], []
    _like_clause('level', f.get('level_like'), where, args)
    _like_clause('program', f.get('program_like'), where, args)
    _like_clause('program', q, where, args)
    rows = _safe_fetch(con, f\"
        SELECT level, program, school, duration, campus, source_file
        FROM programs
        WHERE {' AND '.join(where)}
        ORDER BY level, program
    \", args); con.close()
    cols = ['Level','Program','School','Duration','Campus','Source']
    return {'table':{'title':'Programs','columns':cols,'rows':[
        [r['level'] or '', r['program'] or '', r['school'] or '', r['duration'] or '', r['campus'] or '', r['source_file'] or '']
        for r in rows
    ]}, 'bullets':[]}

def sql_eligibility(f: Dict[str,Any], q: str) -> Dict[str,Any]:
    con = _mk()
    where, args = ['1=1'], []
    _like_clause('level', f.get('level_like'), where, args)
    _like_clause('program', f.get('program_like'), where, args)
    _like_clause('criteria', q, where, args)
    rows = _safe_fetch(con, f\"
        SELECT level, program, criteria, source_file
        FROM eligibility
        WHERE {' AND '.join(where)}
        ORDER BY level, program
    \", args); con.close()
    cols = ['Level','Program','Criteria','Source']
    return {'table':{'title':'Eligibility','columns':cols,'rows':[
        [r['level'] or '', r['program'] or '', r['criteria'] or '', r['source_file'] or '']
        for r in rows
    ]}, 'bullets':[]}

def sql_documents(f: Dict[str,Any], q: str) -> Dict[str,Any]:
    con = _mk()
    where, args = ['1=1'], []
    _like_clause('level', f.get('level_like'), where, args)
    _like_clause('program', f.get('program_like'), where, args)
    _like_clause('item', q, where, args)
    rows = _safe_fetch(con, f\"
        SELECT level, program, item, details, source_file
        FROM documents_required
        WHERE {' AND '.join(where)}
        ORDER BY level, program, item
    \", args); con.close()
    cols = ['Level','Program','Document','Details','Source']
    return {'table':{'title':'Documents Required','columns':cols,'rows':[
        [r['level'] or '', r['program'] or '', r['item'] or '', r['details'] or '', r['source_file'] or '']
        for r in rows
    ]}, 'bullets':[]}

def sql_academic_fees(f: Dict[str,Any], q: str) -> Dict[str,Any]:
    con = _mk()
    where, args = ['1=1'], []
    _like_clause('program', f.get('program_like'), where, args)
    if f.get('level_like'): where.append('LOWER(level)=?'); args.append(f['level_like'].lower())
    if f.get('category'):  where.append('IFNULL(category,\"\")=IFNULL(?, \"\")'); args.append(f['category'])
    if f.get('ay'):        where.append('IFNULL(ay,\"\")=IFNULL(?, \"\")');        args.append(f['ay'])
    _like_clause('program', q, where, args)
    rows = _safe_fetch(con, f\"
        SELECT level, program, category, ay, tuition, one_time, caution, total, currency, source_file
        FROM academic_fees
        WHERE {' AND '.join(where)}
        ORDER BY level, program, category, ay
    \", args); con.close()
    cols = ['Level','Program','Category','AY','Tuition','One-time','Caution','Total','Curr','Source']
    return {'table':{'title':'Academic Fees','columns':cols,'rows':[
        [r['level'] or '', r['program'] or '', r['category'] or '', r['ay'] or '',
         r['tuition'] or '', r['one_time'] or '', r['caution'] or '', r['total'] or '',
         r['currency'] or '', r['source_file'] or '']
        for r in rows
    ]}, 'bullets':[]}

def sql_scholarships(f: Dict[str,Any], q: str) -> Dict[str,Any]:
    con = _mk()
    where, args = ['1=1'], []
    _like_clause('level', f.get('level_like'), where, args)
    _like_clause('name', q, where, args)
    rows = _safe_fetch(con, f\"
        SELECT level, name, criteria, amount, currency, source_file
        FROM scholarships
        WHERE {' AND '.join(where)}
        ORDER BY level, name
    \", args); con.close()
    cols = ['Level','Name','Criteria','Amount','Curr','Source']
    return {'table':{'title':'Scholarships','columns':cols,'rows':[
        [r['level'] or '', r['name'] or '', r['criteria'] or '', r['amount'] or '', r['currency'] or '', r['source_file'] or '']
        for r in rows
    ]}, 'bullets':[]}
""".lstrip()

rag_answer_code = r"""
\"\"\"SQL-first router; FAISS fallback.\"\"\"
from app.sql_router import (
    detect_structured_intent, parse_filters,
    sql_hostel_overview, sql_block_contacts, sql_list_blocks,
    sql_programs, sql_eligibility, sql_documents, sql_academic_fees, sql_scholarships
)

def _fmt_table(tbl: dict) -> str:
    if not tbl or not tbl.get('rows'):
        return '_No matching rows._'
    title  = f\"**{tbl.get('title','Results')}**\"
    cols   = tbl['columns']
    header = ' | '.join(cols)
    sep    = ' | '.join(['---']*len(cols))
    lines  = [title, '', header, sep]
    for r in tbl['rows']:
        lines.append(' | '.join(str(x) if x is not None else '' for x in r))
    return '\\n'.join(lines)

def _pack(table_dict=None, bullets=None):
    parts = []
    if table_dict: parts.append(_fmt_table(table_dict))
    if bullets:    parts.append('\\n'.join(f'- {b}' for b in bullets))
    return '\\n\\n'.join(parts) if parts else '_No results._'

def _sql_route(q: str) -> str | None:
    intent = detect_structured_intent(q)
    f = parse_filters(q)
    if intent == 'contacts':
        return _pack(sql_block_contacts(f).get('table'))
    if intent == 'blocks':
        return _pack(sql_list_blocks(f).get('table'))
    if intent in ('hostel','tabular'):
        return _pack(sql_hostel_overview(f).get('table'))
    if intent == 'programs':
        return _pack(sql_programs(f, q).get('table'))
    if intent == 'eligibility':
        return _pack(sql_eligibility(f, q).get('table'))
    if intent == 'documents':
        return _pack(sql_documents(f, q).get('table'))
    if intent == 'fees':
        return _pack(sql_academic_fees(f, q).get('table'))
    if intent == 'scholarships':
        return _pack(sql_scholarships(f, q).get('table'))
    return None

def answer(query: str) -> str:
    sql_text = _sql_route(query)
    if sql_text is not None:
        return sql_text
    try:
        from app.utils.fallback_rag import answer as rag_fallback
        rag = rag_fallback(query, max_chunks=6, max_tokens=450)
        return rag or '_I couldn't find that in my sources._'
    except Exception:
        return '_I couldn't find that in my sources._'

if __name__ == '__main__':
    import sys
    q = ' '.join(sys.argv[1:]) or 'Show MH Senior NRI hostel fees 2025'
    print(answer(q))
""".lstrip()

# Write files
(APP / "sql_router.py").write_text(sql_router_code, encoding="utf-8")
(APP / "rag_answer.py").write_text(rag_answer_code, encoding="utf-8")

print("[OK] Wrote app/sql_router.py and app/rag_answer.py")

# Basic DB sanity
if not DB.exists():
    print(f"[WARN] DB not found at {DB}. Run ETL/load_sqlite.py first.")
else:
    con = sqlite3.connect(DB)
    counts = {}
    for t in ["programs","eligibility","documents_required","academic_fees","scholarships","hostel_fees"]:
        try:
            counts[t] = con.execute(f"select count(*) from {t}").fetchone()[0]
        except Exception as e:
            counts[t] = f"ERR: {e}"
    con.close()
    print("[DB] counts:", counts)

# Quick functional smoke tests
try:
    from app.sql_router import detect_structured_intent, parse_filters, sql_documents, sql_programs, sql_academic_fees
    print("[TEST] intent(documents):", detect_structured_intent("UG documents required"))
    f = parse_filters("UG documents required")
    r = sql_documents(f, "UG documents required")
    print("[TEST] documents rows:", len(r["table"]["rows"]))

    print("[TEST] intent(programs):", detect_structured_intent("UG programs CSE"))
    f2 = parse_filters("UG programs CSE")
    r2 = sql_programs(f2, "UG programs CSE")
    print("[TEST] programs rows:", len(r2["table"]["rows"]))

    print("[TEST] fees intent:", detect_structured_intent("B.Tech tuition fee Indian 2025"))
    f3 = parse_filters("B.Tech tuition fee Indian 2025")
    r3 = sql_academic_fees(f3, "B.Tech tuition fee Indian 2025")
    print("[TEST] fees rows:", len(r3["table"]["rows"]))
except Exception as e:
    print("[TEST] error:", e)

# Print final answers preview
try:
    from app.rag_answer import answer
    for q in [
        "UG documents required",
        "UG programs CSE",
        "B.Tech tuition fee Indian 2025"
    ]:
        print("\n=== Q:", q)
        out = answer(q)
        # show first 25 lines to keep console readable
        lines = out.splitlines()
        print("\n".join(lines[:25] if len(lines)>25 else lines))
except Exception as e:
    print("[ANSWER] error:", e)
