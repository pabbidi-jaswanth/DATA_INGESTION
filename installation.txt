# app/sql_router.py
"""
Router: SQL-first for fees/programs/eligibility/documents/scholarships/hostel/links.
Key upgrades:
- Degree tokens (btech/mtech/mca/msc) map to LEVEL only (never force PROGRAM).
- Specialization tokens (cse/ece/it/...) map to PROGRAM.
- Robust intent for documents (submit/sumbit/submission), eligibility, links, fees.
- MFA fallback: if MSc/MCA rows don't show up, auto-relax LEVEL to PG, then to ALL.
- Friendlier matching (punctuation/whitespace removed in LIKE).
- 'nri'/'foreign'/'international' => category = International.
- Laundry/dhobi â†’ RAG (not hostel tables).
- Hostel contacts honor gender hints ("mens", "ladies") when possible.
"""

from __future__ import annotations
import sqlite3, pathlib, re
from typing import Dict, Any, List, Optional, Tuple

DB = pathlib.Path("Data/sql/vit_vellore.db")

# ------------------ helpers ------------------

def _norm_text(s: str) -> str:
    s = s.lower().replace("&", "and")
    return re.sub(r"[^a-z0-9]+", "", s)

def _norm_like(value: Optional[str]) -> Optional[str]:
    return f"%{_norm_text(value)}%" if value else None

def _add_norm_like_clause(col: str, val: Optional[str], where: List[str], args: List[str]) -> None:
    if not val:
        return
    # remove dots, dashes, spaces; lowercase; &->and
    expr = (
        f"REPLACE(REPLACE(REPLACE(REPLACE(LOWER({col}),'.',''),'-',''),'&','and'),' ','')"
    )
    where.append(f"{expr} LIKE ?")
    args.append(_norm_like(val))

def _mk():
    con = sqlite3.connect(DB)
    con.row_factory = sqlite3.Row
    return con

def _safe_fetch(con, sql: str, args: List[Any]) -> List[sqlite3.Row]:
    try:
        return con.execute(sql, args).fetchall()
    except sqlite3.OperationalError:
        return []

# ------------------ intent ------------------

ACA_KEYWORDS = {
    "programs": ["program","programs","course","courses","degree","offered","b.tech","m.tech","mca","msc","btech","mtech"],
    "eligibility": ["eligibility","qualify","criteria","requirement","requirements","min marks","minimum marks","cutoff","cut-off"],
    # include common misspellings of submit
    "documents": ["document","documents","docs","upload","certificate","proof","bonafide",
                  "to be submit","to be submitted","submission","sumbit","symbited","submit","sumbited","sumbitted"],
    "fees": ["tuition","fee","fees","academic fee","semester fee","fee structure","structure","charges","cost","price"],
    "scholarships": ["scholarship","scholarships","waiver","merit","financial aid","fee concession","freeship"],
    "links": ["link","links","url","website","apply link","application link","brochure","portal"]
}

def _contains_any(q: str, words: List[str]) -> bool:
    ql = q.lower()
    return any(w in ql for w in words)

def detect_structured_intent(q: str) -> str:
    ql = q.lower()

    # Small hostel sub-cases that should go to RAG (not SQL tables)
    if any(w in ql for w in ["laundry","dhobi","washing","wash"]):
        return "text"

    # Hostel
    if any(k in ql for k in ["contact","phone","email","supervisor","warden","director","manager"]):
        return "contacts"
    if "block" in ql and any(k in ql for k in ["name","names","list","all","codes","code"]):
        return "blocks"
    if any(k in ql for k in ["hostel","room","mess","mh","lh","ac","non-ac","canteen"]):
        return "hostel"

    # Academics (order matters: fees first to avoid false positives)
    if _contains_any(ql, ACA_KEYWORDS["fees"]): return "fees"
    if _contains_any(ql, ACA_KEYWORDS["links"]): return "links"
    for tag in ("programs","eligibility","documents","scholarships"):
        if _contains_any(ql, ACA_KEYWORDS[tag]): return tag

    # Narrative flows (application/refund/how-to) -> RAG
    if any(w in ql for w in [
        "application process","admission process","how to apply","refund","cancellation",
        "deadline","last date","when","why","what","who","how"
    ]):
        return "text"

    # default: let RAG try
    return "text"

# ------------------ query parsing ------------------

DEGREE_TOKENS = {
    "btech": [r"b\.?\s*tech", r"\bbtech\b"],
    "mtech": [r"m\.?\s*tech", r"\bmtech\b"],
    "mca":   [r"\bmca\b"],
    "msc":   [r"m\.?\s*sc", r"\bmsc\b"],
}

SPECIALIZATION_TOKENS = [
    "computer science","cse","it","information technology","ece","eee","mechanical","mech",
    "civil","biotech","biotechnology","ai","data","vlsi","cyber","software","chemistry",
    "physics","mathematics","maths","bioinformatics","blockchain","robotics",
    "data science","gaming","health informatics","education technology","smart manufacturing"
]

def _find_degree_token(q: str) -> Optional[str]:
    ql = q.lower()
    for norm, pats in DEGREE_TOKENS.items():
        for p in pats:
            if re.search(p, ql, flags=re.I):
                return norm
    return None

def _find_specialization(q: str) -> Optional[str]:
    ql = q.lower()
    for term in sorted(SPECIALIZATION_TOKENS, key=len, reverse=True):
        if term in ql:
            return term
    return None

def _ay_from_text(q: str) -> Optional[str]:
    m = re.search(r"\b(20\d{2})\b", q)
    if not m:
        return None
    yr = m.group(1)
    return f"{yr}-{str(int(yr[-2:]) + 1).zfill(2)}"

def parse_filters(q: str) -> Dict[str, Any]:
    ql = q.lower()
    f: Dict[str, Any] = {
        "ay": _ay_from_text(q),
        "gender": None,
        "category": None,
        "level_like": None,
        "program_like": None,
        "prog_is_degree": False,   # if True, program_like only comes from specialization (not from degree)
        "raw_degree": None,
    }
    # gender hints (hostel)
    if any(k in ql for k in ["boy","boys","men","mh","mens","male"]): f["gender"] = "Male"
    if any(k in ql for k in ["girl","girls","ladies","lh","women","female"]): f["gender"] = "Female"

    # category
    if any(k in ql for k in ["nri","foreign","international"]):
        f["category"] = "International"
    elif "indian" in ql:
        f["category"] = "Indian"

    # degree -> level_like (never force PROGRAM from degree)
    deg = _find_degree_token(q)
    f["raw_degree"] = deg
    if deg == "btech":
        f["level_like"] = "UG"
        f["prog_is_degree"] = True
    elif deg == "mtech":
        f["level_like"] = "PG"
        f["prog_is_degree"] = True
    elif deg == "mca":
        # many rows store 'MCA' in level or under PG; we start with 'mca' and can relax later
        f["level_like"] = "mca"
        f["prog_is_degree"] = True
    elif deg == "msc":
        # many rows store 'M.Sc' in level or under PG; we start with 'msc' and can relax later
        f["level_like"] = "msc"
        f["prog_is_degree"] = True

    # explicit UG/PG words
    if " ug" in f" {ql}": f["level_like"] = f["level_like"] or "UG"
    if " pg" in f" {ql}": f["level_like"] = f["level_like"] or "PG"

    # specialization -> program_like (this can narrow results even when degree found)
    spec = _find_specialization(q)
    if spec:
        f["program_like"] = spec
        f["prog_is_degree"] = False

    return f

# ------------------ table formatter ------------------

def _fmt_table(tbl: dict) -> str:
    if not tbl or not tbl.get("rows"):
        return "_No matching rows._"
    title  = f"**{tbl.get('title','Results')}**"
    cols   = tbl["columns"]
    header = " | ".join(cols)
    sep    = " | ".join(["---"] * len(cols))
    lines  = [title, "", header, sep]
    for r in tbl["rows"]:
        lines.append(" | ".join("" if x is None else str(x) for x in r))
    return "\n".join(lines)

def _pack(table_dict=None, bullets=None) -> str:
    parts = []
    if table_dict: parts.append(_fmt_table(table_dict))
    if bullets:    parts.append("\n".join(f"- {b}" for b in bullets))
    return "\n".join(parts) if parts else "_No results._"

# ------------------ hostel SQL ------------------

def sql_hostel_overview(f: Dict[str,Any], limit_rows: int = 800) -> Dict[str, Any]:
    con = _mk()
    where: List[str] = ["1=1"]; args: List[Any] = []
    if f["gender"]:     where.append("IFNULL(b.gender,'') = IFNULL(?, '')");     args.append(f["gender"])
    if f["level_like"]: where.append("IFNULL(b.level,'') LIKE IFNULL(?, '')");   args.append(f"%{f['level_like']}%")
    if f["ay"]:         where.append("IFNULL(hf.ay,'') = IFNULL(?, '')");        args.append(f["ay"])
    if f["category"]:   where.append("IFNULL(hf.category,'') = IFNULL(?, '')");  args.append(f["category"])
    sql = f"""
    SELECT b.display_name AS block, b.gender, b.level, b.block_type,
           hf.ay, hf.category, hf.occupancy, hf.ac, hf.mess_type,
           hf.room_mess_fee, hf.admission_fee, hf.caution_deposit, hf.other_fee, hf.total_fee, hf.currency,
           hf.source_file
    FROM hostel_fees hf
    JOIN blocks b ON b.id = hf.block_id
    WHERE {' AND '.join(where)}
    ORDER BY b.block_type, block, hf.occupancy, hf.ac DESC, hf.mess_type
    """
    rows = _safe_fetch(con, sql, args); con.close()
    columns = ["Block","Gender","Level","Type","AY","Category","Occ","AC","Mess",
               "Room+Mess","Admission","Caution","Other","Total","Curr","Source"]
    tbl = {"title":"Hostel Fee Details (Vellore)", "columns":columns, "rows":[]}
    for r in rows[:limit_rows]:
        tbl["rows"].append([
            r["block"] or "", r["gender"] or "", r["level"] or "", r["block_type"] or "",
            r["ay"] or "", r["category"] or "", r["occupancy"] or "",
            "AC" if (r["ac"] == 1) else ("Non-AC" if (r["ac"] == 0) else ""),
            r["mess_type"] or "", r["room_mess_fee"] or "", r["admission_fee"] or "",
            r["caution_deposit"] or "", r["other_fee"] or "", r["total_fee"] or "",
            r["currency"] or "", r["source_file"] or ""
        ])
    return {"table": tbl, "bullets": []}

def sql_block_contacts(f: Dict[str,Any]) -> Dict[str,Any]:
    con = _mk()
    # Optional gender-aware filter based on role text (MH/LH hints)
    where: List[str] = ["1=1"]; args: List[Any] = []
    if f.get("gender") == "Male":
        where.append("(LOWER(role) LIKE '%(mh)%' OR LOWER(role) LIKE '%men%' OR LOWER(role) LIKE '%male%' OR LOWER(role) LIKE '%men''s%')")
    elif f.get("gender") == "Female":
        where.append("(LOWER(role) LIKE '%(lh)%' OR LOWER(role) LIKE '%ladies%' OR LOWER(role) LIKE '%female%' OR LOWER(role) LIKE '%women%')")
    sql = f"""
        SELECT '' AS block, name, role, phone, email
        FROM hostel_contacts
        WHERE {' AND '.join(where)}
        ORDER BY role, name
    """
    rows = _safe_fetch(con, sql, args); con.close()
    cols = ["Block","Name","Role","Phone","Email"]
    tbl = {"title":"Hostel Contacts", "columns":cols, "rows":[
        [r["block"], r["name"] or "", r["role"] or "", r["phone"] or "", r["email"] or ""]
        for r in rows
    ]}
    return {"table": tbl, "bullets": []}

def sql_list_blocks(f: Dict[str,Any]) -> Dict[str,Any]:
    con = _mk()
    if f["gender"] == "Female":
        sql = "SELECT block_code AS display_name, 'Female' AS gender FROM lh_blocks ORDER BY block_code"
        args: List[Any] = []
    elif f["gender"] == "Male":
        sql = "SELECT COALESCE(block_name, block_code) AS display_name, 'Male' AS gender FROM mh_blocks ORDER BY block_code"
        args = []
    else:
        sql = """
        SELECT COALESCE(block_name, block_code) AS display_name, 'Male' AS gender FROM mh_blocks
        UNION ALL
        SELECT block_code AS display_name, 'Female' AS gender FROM lh_blocks
        ORDER BY gender, display_name
        """
        args = []
    rows = _safe_fetch(con, sql, args); con.close()
    cols = ["Block","Gender"]
    tbl = {"title":"Hostel Blocks", "columns":cols, "rows":[
        [r["display_name"] or "", r["gender"] or ""]
        for r in rows
    ]}
    return {"table": tbl, "bullets": []}

# ------------------ academics SQL ------------------

def _select(con, table: str, cols: List[str], where: List[str], args: List[Any], order_by: str) -> List[sqlite3.Row]:
    sql = f"SELECT {', '.join(cols)} FROM {table} WHERE {' AND '.join(where)} {order_by}"
    return _safe_fetch(con, sql, args)

def _relax_mca_msc_if_needed(
    con,
    table: str,
    cols: List[str],
    where: List[str],
    args: List[Any],
    order_by: str,
    f: Dict[str,Any]
) -> Tuple[List[sqlite3.Row], List[Any]]:
    """
    For MSc/MCA rows: some datasets place them under LEVEL='PG' (or leave LEVEL blank).
    Strategy: run given query; if empty and raw_degree in {'msc','mca'}:
        1) retry with LEVEL LIKE '%PG%'
        2) retry with NO LEVEL filter
    """
    # 0) original
    rows = _select(con, table, cols, where, args, order_by)
    if rows:
        return rows, args

    if f.get("raw_degree") not in {"msc","mca"}:
        return rows, args

    # Helper: remove any clause that references "level" expr
    def _strip_level(wlist: List[str]) -> List[str]:
        return [w for w in wlist if ("LOWER(level)" not in w and "REPLACE(" not in w and "level" not in w.lower())]

    # 1) force PG
    where_pg: List[str] = _strip_level(where.copy())
    args_pg: List[Any] = []
    where_pg.insert(0, "1=1")
    _add_norm_like_clause("level", "pg", where_pg, args_pg)
    rows_pg = _select(con, table, cols, where_pg, args_pg, order_by)
    if rows_pg:
        return rows_pg, args_pg

    # 2) no level filter
    where_all: List[str] = _strip_level(where.copy())
    if not where_all:
        where_all = ["1=1"]
    rows_all = _select(con, table, cols, where_all, args, order_by="")
    if rows_all:
        return rows_all, args

    return [], args

def sql_programs(f: Dict[str,Any], _q: str) -> Dict[str,Any]:
    con = _mk()
    where, args = ["1=1"], []
    _add_norm_like_clause("level", f["level_like"], where, args)
    if f["program_like"] and not f["prog_is_degree"]:
        _add_norm_like_clause("program", f["program_like"], where, args)
    rows = _select(con, "programs",
                   ["level","program","school","duration","campus","source_file"],
                   where, args, "ORDER BY level, program")
    con.close()
    cols = ["Level","Program","School","Duration","Campus","Source"]
    return {"table":{"title":"Programs","columns":cols,"rows":[
        [r["level"] or "", r["program"] or "", r["school"] or "", r["duration"] or "", r["campus"] or "", r["source_file"] or ""]
        for r in rows
    ]}}

def sql_eligibility(f: Dict[str,Any], q: str) -> Dict[str,Any]:
    con = _mk()
    base_where, base_args = ["1=1"], []
    _add_norm_like_clause("level", f["level_like"], base_where, base_args)
    if f["program_like"] and not f["prog_is_degree"]:
        _add_norm_like_clause("program", f["program_like"], base_where, base_args)
    # Do NOT over-filter by entire question text; optional soft match:
    # _add_norm_like_clause("criteria", q, base_where, base_args)

    cols = ["level","program","criteria","source_file"]
    rows, _ = _relax_mca_msc_if_needed(
        con, "eligibility", cols, base_where, base_args, "ORDER BY level, program", f
    )
    con.close()
    return {"table":{"title":"Eligibility","columns":["Level","Program","Criteria","Source"],"rows":[
        [r["level"] or "", r["program"] or "", r["criteria"] or "", r["source_file"] or ""]
        for r in rows
    ]}}

def sql_documents(f: Dict[str,Any], q: str) -> Dict[str,Any]:
    con = _mk()
    base_where, base_args = ["1=1"], []
    _add_norm_like_clause("level", f["level_like"], base_where, base_args)
    if f["program_like"] and not f["prog_is_degree"]:
        _add_norm_like_clause("program", f["program_like"], base_where, base_args)
    # optional soft narrowing: search "item" by query text (kept very loose)
    if q:
        _add_norm_like_clause("item", q, base_where, base_args)

    cols = ["level","program","item","details","source_file"]
    rows, _ = _relax_mca_msc_if_needed(
        con, "documents_required", cols, base_where, base_args, "ORDER BY level, program, item", f
    )
    con.close()
    return {"table":{"title":"Documents Required","columns":["Level","Program","Document","Details","Source"],"rows":[
        [r["level"] or "", r["program"] or "", r["item"] or "", r["details"] or "", r["source_file"] or ""]
        for r in rows
    ]}}

def sql_academic_fees(f: Dict[str,Any], _q: str) -> Dict[str,Any]:
    con = _mk()
    where, args = ["1=1"], []
    if f["program_like"] and not f["prog_is_degree"]:
        _add_norm_like_clause("program", f["program_like"], where, args)
    _add_norm_like_clause("level", f["level_like"], where, args)
    if f["ay"]:
        where.append("IFNULL(ay,'') = IFNULL(?, '')");        args.append(f["ay"])
    if f["category"]:
        where.append("IFNULL(category,'') = IFNULL(?, '')");  args.append(f["category"])
    rows = _select(con, "academic_fees",
                   ["level","program","category","ay","tuition","one_time","caution","total","currency","source_file"],
                   where, args, "ORDER BY level, program, category, ay")
    con.close()
    cols = ["Level","Program","Category","AY","Tuition","One-time","Caution","Total","Curr","Source"]
    return {"table":{"title":"Academic Fees","columns":cols,"rows":[
        [r["level"] or "", r["program"] or "", r["category"] or "", r["ay"] or "",
         r["tuition"] or "", r["one_time"] or "", r["caution"] or "", r["total"] or "",
         r["currency"] or "", r["source_file"] or ""]
        for r in rows
    ]}}

def sql_scholarships(f: Dict[str,Any], q: str) -> Dict[str,Any]:
    con = _mk()
    where, args = ["1=1"], []
    _add_norm_like_clause("level", f["level_like"], where, args)
    # optional name narrowing:
    if q:
        _add_norm_like_clause("name", q, where, args)
    rows = _select(con, "scholarships",
                   ["level","name","criteria","amount","currency","source_file"],
                   where, args, "ORDER BY level, name")
    con.close()
    cols = ["Level","Name","Criteria","Amount","Curr","Source"]
    return {"table":{"title":"Scholarships","columns":cols,"rows":[
        [r["level"] or "", r["name"] or "", r["criteria"] or "", r["amount"] or "", r["currency"] or "", r["source_file"] or ""]
        for r in rows
    ]}}

def sql_links(f: Dict[str,Any], _q: str) -> Dict[str,Any]:
    """
    Optional table `links(level, program, name, url, source_file)`.
    If the table doesn't exist, return an empty table so RAG can try.
    """
    con = _mk()
    try:
        con.execute("SELECT 1 FROM links LIMIT 1")
    except sqlite3.OperationalError:
        con.close()
        return {"table":{"title":"Links","columns":["Level","Program","Name","URL","Source"],"rows":[]}}

    where, args = ["1=1"], []
    _add_norm_like_clause("level", f["level_like"], where, args)
    if f["program_like"] and not f["prog_is_degree"]:
        _add_norm_like_clause("program", f["program_like"], where, args)

    rows = _select(con, "links",
                   ["level","program","name","url","source_file"],
                   where, args, "ORDER BY level, program, name")
    con.close()
    cols = ["Level","Program","Name","URL","Source"]
    return {"table":{"title":"Links","columns":cols,"rows":[
        [r["level"] or "", r["program"] or "", r["name"] or "", r["url"] or "", r["source_file"] or ""]
        for r in rows
    ]}}

# ------------------ router ------------------

def _sql_route(q: str) -> Optional[str]:
    intent = detect_structured_intent(q)
    f = parse_filters(q)

    # Hostel
    if intent == "contacts": return _pack(sql_block_contacts(f).get("table"))
    if intent == "blocks":   return _pack(sql_list_blocks(f).get("table"))
    if intent == "hostel":   return _pack(sql_hostel_overview(f).get("table"))

    # Academics
    if intent == "links":        return _pack(sql_links(f, q).get("table"))
    if intent == "programs":     return _pack(sql_programs(f, q).get("table"))
    if intent == "eligibility":  return _pack(sql_eligibility(f, q).get("table"))
    if intent == "documents":    return _pack(sql_documents(f, q).get("table"))
    if intent == "fees":         return _pack(sql_academic_fees(f, q).get("table"))
    if intent == "scholarships": return _pack(sql_scholarships(f, q).get("table"))

    # Narrative or unclear â†’ let caller (rag_answer) decide
    return None

# ------------------ public ------------------

def answer(query: str) -> str:
    sql_text = _sql_route(query)
    if sql_text is not None and sql_text.strip() != "_No matching rows._":
        return sql_text
    # leave the friendly fallback to app.rag_answer (FAISS or default)
    return "_No matching rows._"

if __name__ == "__main__":
    import sys
    q = " ".join(sys.argv[1:]) or "Show MH Senior NRI hostel fees 2025"
    print(answer(q))
