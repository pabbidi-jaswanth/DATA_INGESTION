# streamlit_app.py
# VIT FAQs — Static click-to-answer UI
# Sections: UG, PG, MCA, MSc, HOSTELS
# UG policy: ONLY "Programs" and "Fees" use SQLite; everything else uses FAISS (PDFs).

import pathlib
from typing import Dict, Any, List, Tuple
import re
import copy

import streamlit as st

# ---- your backend helpers (must exist) ----
from app.sql_router import (
    sql_programs,        # Programs table accessor
    sql_academic_fees,   # Fees table accessor
)
from app.utils.fallback_rag import faiss_answer_or_summary

# ---- config ----
FAISS_INDEX_DIR = pathlib.Path("Data/index/faiss")

# Per-section FAISS collections (already built by your ETL script)
FAISS_COLLECTIONS = {
    "UG": "vit_ug",
    "PG": "vit_pg",
    "MCA": "vit_pg",      # your MCA PDFs are inside PG; switch to vit_mca if you build it later
    "MSc": "vit_pg",      # same note; switch to vit_msc if you build it later
    "HOSTELS": "vit_hostels",
}

st.set_page_config(page_title="VIT FAQs — Click to Answer", layout="wide")

# ===================== UG — questions =====================
UG_REG: List[Dict[str, Any]] = [
    # ---- SQL (Programs) ----
    {"label": "What UG programs and specializations are offered?",
     "handler": "programs", "filters": {"level_like": "UG"}},
    {"label": "Which B.Tech specializations are available at each campus?",
     "handler": "programs", "filters": {"level_like": "UG", "program_like": "B.Tech"}},
    {"label": "What non–B.Tech UG programs are offered (BBA/B.Com/BCA etc.)?",
     "handler": "programs", "filters": {"level_like": "UG", "program_like": "BBA B.Com BCA"}},

    # ---- FAISS (PDFs) ----
    {"label": "UG eligibility: minimum marks and required subjects", "handler": "faiss_summary", "filters": {}},
    {"label": "Is Mathematics mandatory for specific B.Tech programs?", "handler": "faiss_summary", "filters": {}},
    {"label": "Are NIOS/correspondence students eligible for UG?", "handler": "faiss_summary", "filters": {}},
    {"label": "Eligibility for NRI/OCI/PIO applicants (UG)", "handler": "faiss_summary", "filters": {}},

    {"label": "Documents to submit for UG admission and reporting", "handler": "faiss_summary", "filters": {}},
    {"label": "Where to download affidavits and fitness forms?", "handler": "faiss_summary", "filters": {}},
    {"label": "Photo/signature/document upload specifications", "handler": "faiss_summary", "filters": {}},

    # ---- SQL (Fees) ----
    {"label": "UG tuition fee (Indian category) for AY 2025–26",
     "handler": "fees", "filters": {"level_like": "UG", "category": "Indian", "ay": "2025-26"}},
    # (Per your call earlier, we removed UG NRI/Foreign fee buttons if those rows aren’t reliable in DB)

    # ---- FAISS (PDFs) ----
    {"label": "Is there a refundable caution deposit for UG?", "handler": "faiss_summary", "filters": {}},
    {"label": "Scholarships/waivers available for UG students", "handler": "faiss_summary", "filters": {}},

    {"label": "Step-by-step UG application process (Indian/NRI/Foreign)", "handler": "faiss_summary", "filters": {}},
    {"label": "Important admission dates and deadlines for UG", "handler": "faiss_summary", "filters": {}},
    {"label": "How is the merit list prepared and tie-break rules?", "handler": "faiss_summary", "filters": {}},
    {"label": "Counselling and seat allotment process (rounds and sliding)", "handler": "faiss_summary", "filters": {}},
    {"label": "Branch locking and later branch-change policy", "handler": "faiss_summary", "filters": {}},

    {"label": "Who is treated as NRI vs Foreign applicant?", "handler": "faiss_summary", "filters": {}},
    {"label": "NRI application portal & fee payment instructions", "handler": "faiss_summary", "filters": {}},
    {"label": "Foreign nationals/OCI/PIO application steps & fees", "handler": "faiss_summary", "filters": {}},

    # HOSTEL & CONTACTS → FAISS
    {"label": "First-year hostel fee (Indian) AY 2025–26", "handler": "faiss_summary", "filters": {}},
    {"label": "First-year hostel fee (NRI/Foreign) AY 2025–26", "handler": "faiss_summary", "filters": {}},
    {"label": "Senior hostel fee overview AY 2025–26", "handler": "faiss_summary", "filters": {}},
    {"label": "Hostel block landlines and key contacts", "handler": "faiss_summary", "filters": {}},

    {"label": "Extra documents for NRI/Foreign students at reporting", "handler": "faiss_summary", "filters": {}},
    {"label": "AIU equivalence and accepted international boards", "handler": "faiss_summary", "filters": {}},

    {"label": "Mode and schedule of tuition/hostel fee payment", "handler": "faiss_summary", "filters": {}},
    {"label": "Refund policy if I withdraw before/after registration", "handler": "faiss_summary", "filters": {}},

    {"label": "When to pay balance tuition/hostel after provisional admission?", "handler": "faiss_summary", "filters": {}},
    {"label": "How to check application status and download letters?", "handler": "faiss_summary", "filters": {}},
    {"label": "How to correct mistakes in the application after submission?", "handler": "faiss_summary", "filters": {}},
    {"label": "Uploading pending 12th/board marks and verification process", "handler": "faiss_summary", "filters": {}},

    {"label": "Medium of instruction and availability of bridge courses", "handler": "faiss_summary", "filters": {}},
    {"label": "Attendance, exams and grading policy (UG) overview", "handler": "faiss_summary", "filters": {}},

    {"label": "Internships and industry-linked projects during UG", "handler": "faiss_summary", "filters": {}},
    {"label": "Recent UG placement highlights & top recruiters", "handler": "faiss_summary", "filters": {}},

    {"label": "Whom to contact for UG admissions help (email/phone)?", "handler": "faiss_summary", "filters": {}},
]

# ======== Simple placeholder registries for other sections (FAISS only) ========
PG_REG = [
    {"label": "PG eligibility and degree requirements", "handler": "faiss_summary", "filters": {}},
    {"label": "VITMEE/VITREE application steps and schedule", "handler": "faiss_summary", "filters": {}},
    {"label": "PG documents to submit and reporting checklist", "handler": "faiss_summary", "filters": {}},
    {"label": "PG counselling / seat allotment overview", "handler": "faiss_summary", "filters": {}},
]

MCA_REG = [
    {"label": "MCA eligibility: qualifying degree and marks", "handler": "faiss_summary", "filters": {}},
    {"label": "MCA application process & important dates", "handler": "faiss_summary", "filters": {}},
    {"label": "MCA syllabus/structure overview", "handler": "faiss_summary", "filters": {}},
    {"label": "MCA placements & top recruiters (recent)", "handler": "faiss_summary", "filters": {}},
]

MSC_REG = [
    {"label": "M.Sc programmes & specializations", "handler": "faiss_summary", "filters": {}},
    {"label": "M.Sc eligibility and subject prerequisites", "handler": "faiss_summary", "filters": {}},
    {"label": "M.Sc application process & timeline", "handler": "faiss_summary", "filters": {}},
    {"label": "M.Sc evaluation/attendance pattern", "handler": "faiss_summary", "filters": {}},
]

HST_REG = [
    {"label": "Hostel fee heads and refund policy (overview)", "handler": "faiss_summary", "filters": {}},
    {"label": "First-year hostel process & check-in documents", "handler": "faiss_summary", "filters": {}},
    {"label": "Hostel contact numbers & block landlines", "handler": "faiss_summary", "filters": {}},
    {"label": "Mess options and general rules", "handler": "faiss_summary", "filters": {}},
]

# ===================== helpers (key-mapping + SQL backoff) =====================
def _md_table(table: Dict[str, Any]) -> str:
    if not table or not table.get("columns") or not table.get("rows"):
        return "_No results._"
    cols = table["columns"]; rows = table["rows"]
    lines = [" | ".join(cols), " | ".join(["---"] * len(cols))]
    for r in rows:
        lines.append(" | ".join("" if x is None else str(x) for x in r))
    return "\n".join(lines)

def _normalize_for_programs(filters: Dict[str, Any]) -> Dict[str, Any]:
    f = dict(filters or {})
    lvl = f.get("level", f.get("level_like", "UG"))
    f["level"] = lvl
    f["level_like"] = lvl
    prog_like = f.get("program_like", f.get("prog_like"))
    if prog_like is not None:
        f["program_like"] = prog_like
        f["prog_like"] = prog_like
    f.setdefault("prog_is_degree", True)
    f.setdefault("prog_level_like", lvl)
    return f

def _normalize_for_fees(filters: Dict[str, Any]) -> Dict[str, Any]:
    f = dict(filters or {})
    # normalize level
    lvl = f.get("level", f.get("level_like", "UG"))
    f["level"] = lvl
    f["level_like"] = lvl
    # normalize category (Foreign → International)
    cat = f.get("category", f.get("fee_category"))
    if cat is not None:
        cat_norm = str(cat).strip()
        if cat_norm.lower() == "foreign":
            cat_norm = "International"
        f["category"] = cat_norm
        f["fee_category"] = cat_norm
    # normalize AY (dash variants, accept 'AY')
    ay = f.get("ay", f.get("AY", f.get("academic_year", "2025-26")))
    ay = str(ay).replace("–", "-").replace("—", "-")
    f["ay"] = ay
    f["AY"] = ay
    f["academic_year"] = ay
    # optional program filter
    prog_like = f.get("program_like", f.get("prog_like"))
    if prog_like is not None:
        f["program_like"] = prog_like
        f["prog_like"] = prog_like
    # some routers expect this even in fees path
    f.setdefault("prog_is_degree", True)
    return f

def _keyerror_field(ex: Exception) -> str:
    # extract offending key from KeyError('key') or KeyError("key")
    m = re.search(r"KeyError:?[^\w]*'([^']+)'", repr(ex))
    return m.group(1) if m else ""

def _call_with_key_backoff(fn, base_filters: Dict[str, Any], *args, **kwargs):
    """
    Calls a SQL router function with filters. If it raises KeyError('k'),
    drop that key from the filters and retry. Limit a few retries.
    """
    filt = copy.deepcopy(base_filters)
    tried = set()
    for _ in range(6):  # up to 6 removals
        try:
            return fn(filt, *args, **kwargs)
        except KeyError as e:
            k = _keyerror_field(e)
            if not k or k in tried or k not in filt:
                raise
            tried.add(k)
            filt.pop(k, None)
    # final attempt without any filters if all else fails
    return fn({}, *args, **kwargs)

def _sql_programs(filters: Dict[str, Any]) -> Tuple[bool, Dict[str, Any], str]:
    def _to_table(out):
        return out["table"] if isinstance(out, dict) and "table" in out else out
    try:
        f1 = _normalize_for_programs(filters)
        t1 = _to_table(_call_with_key_backoff(sql_programs, f1, ""))
        if t1 and t1.get("columns") and t1.get("rows"):
            return True, t1, ""
        # backoff: only level
        f2 = {"level": "UG", "level_like": "UG", "prog_is_degree": True}
        t2 = _to_table(_call_with_key_backoff(sql_programs, f2, ""))
        if t2 and t2.get("rows"):
            return True, t2, ""
        # last try: empty
        t3 = _to_table(_call_with_key_backoff(sql_programs, {"prog_is_degree": True}, ""))
        if t3 and t3.get("rows"):
            return True, t3, ""
        return False, {}, "no_rows"
    except KeyError as e:
        return False, {}, f"keyerror:{e}"
    except Exception as e:
        return False, {}, f"exception:{e}"

def _sql_fees(filters: Dict[str, Any]) -> Tuple[bool, Dict[str, Any], str]:
    def _to_table(out):
        return out["table"] if isinstance(out, dict) and "table" in out else out
    try:
        f1 = _normalize_for_fees(filters)
        t1 = _to_table(_call_with_key_backoff(sql_academic_fees, f1, ""))
        if t1 and t1.get("columns") and t1.get("rows"):
            return True, t1, ""
        # backoff: only level
        f2 = {"level": "UG", "level_like": "UG"}
        t2 = _to_table(_call_with_key_backoff(sql_academic_fees, f2, ""))
        if t2 and t2.get("rows"):
            return True, t2, ""
        # last try: empty
        t3 = _to_table(_call_with_key_backoff(sql_academic_fees, {}, ""))
        if t3 and t3.get("rows"):
            return True, t3, ""
        return False, {}, "no_rows"
    except KeyError as e:
        return False, {}, f"keyerror:{e}"
    except Exception as e:
        return False, {}, f"exception:{e}"

def _dispatch(handler: str, filters: Dict[str, Any], fallback_query: str, collection: str) -> Dict[str, Any]:
    """
    Policy:
      - SQL ONLY for handler in {'programs','fees'}.
      - Everything else -> FAISS (PDFs), against the collection for the current section.
    """
    if handler == "programs":
        ok, table, err = _sql_programs(filters)
        return {"type": "table" if ok else "error",
                "content": table if ok else f"SQL(programs) → {err}"}

    if handler == "fees":
        ok, table, err = _sql_fees(filters)
        return {"type": "table" if ok else "error",
                "content": table if ok else f"SQL(fees) → {err}"}

    # FAISS for everything else
    try:
        # Slightly contextualize the query with the section label to steer retrieval
        q = f"[{collection}] {fallback_query}"
        md = faiss_answer_or_summary(FAISS_INDEX_DIR, collection, q, top_k=10)
        return {"type": "md", "content": md or "_No context found in PDFs._"}
    except Exception as e:
        return {"type": "error", "content": f"FAISS error: {e}"}

def _render_answer(result: Dict[str, Any]):
    if result["type"] == "table":
        table = result["content"]
        cols = table.get("columns") or []; rows = table.get("rows") or []
        if cols and rows:
            import pandas as pd
            df = pd.DataFrame(rows, columns=cols)
            st.dataframe(df, use_container_width=True, hide_index=True)
            with st.expander("Copy as Markdown"):
                st.code(_md_table(table), language="markdown")
        else:
            st.warning("No rows.")
    elif result["type"] == "md":
        st.markdown(result["content"])
    else:
        st.error(result["content"])

# ===================== UI =====================
st.title("🎓 VIT — Static FAQs (Click to Answer)")

section = st.radio("Choose a section", ["UG", "PG", "MCA", "MSc", "HOSTELS"], horizontal=True)
REG_MAP = {"UG": UG_REG, "PG": PG_REG, "MCA": MCA_REG, "MSc": MSC_REG, "HOSTELS": HST_REG}
REG = REG_MAP[section]

left, right = st.columns([1.3, 2.0], gap="large")

with left:
    st.subheader(f"{section} — Questions")
    qf = st.text_input("Filter", placeholder="type to filter…").strip().lower()
    filtered = [r for r in REG if (qf in r["label"].lower())] if qf else REG
    for i, row in enumerate(filtered):
        if st.button(row["label"], key=f"{section}-{i}"):
            st.session_state["selected_item"] = (section, row)

with right:
    st.subheader("Answer")
    sel = st.session_state.get("selected_item")
    if not sel:
        st.info("Click a question on the left.")
    else:
        cur_section, item = sel
        label   = item["label"]
        handler = item["handler"]
        filters = item.get("filters") or {}
        with st.spinner("Fetching…"):
            result = _dispatch(handler, filters, label, FAISS_COLLECTIONS[cur_section])
        st.markdown(f"**{label}**")
        _render_answer(result)

st.caption(
    "Routing: UG Programs & Fees → SQLite tables (with key-backoff); all other answers → section-specific PDFs via FAISS "
    f"(UG→{FAISS_COLLECTIONS['UG']}, PG→{FAISS_COLLECTIONS['PG']}, MCA→{FAISS_COLLECTIONS['MCA']}, "
    f"MSc→{FAISS_COLLECTIONS['MSc']}, HOSTELS→{FAISS_COLLECTIONS['HOSTELS']})."
)
