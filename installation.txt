# app/rag_answer.py
"""
Top-level QA entrypoint.
- SQL-first
- Smalltalk answers for generic asks
- RAG fallback: FAISS; else PDF text search; else short apology
- Accepts both --q "..." and positional query
"""

from app.sql_router import (
    detect_structured_intent, parse_filters,
    sql_hostel_overview, sql_block_contacts, sql_list_blocks,
    sql_programs, sql_eligibility, sql_documents, sql_academic_fees, sql_scholarships
)

# ---------- render helpers ----------

def _fmt_table(tbl: dict) -> str:
    if not tbl or not tbl.get("rows"):
        return "_No matching rows._"
    title  = f"**{tbl.get('title','Results')}**"
    cols   = tbl["columns"]
    header = " | ".join(cols)
    sep    = " | ".join(["---"] * len(cols))
    lines  = [title, "", header, sep]
    for r in tbl["rows"]:
        lines.append(" | ".join("" if x is None else str(x) for x in r))
    return "\n".join(lines)

def _pack(table_dict=None, bullets=None):
    parts = []
    if table_dict: parts.append(_fmt_table(table_dict))
    if bullets:    parts.append("\n".join(f"- {b}" for b in bullets))
    return "\n".join(parts) if parts else "_No results._"

# ---------- smalltalk ----------

def _smalltalk_answer(q: str) -> str | None:
    ql = q.lower().strip()
    if ql in {"hi","hello","hey"}:
        return "Hi! I’m the VIT Admissions Chatbot. Ask me about fees, eligibility, documents, programs, hostel, links, or the application/refund process."
    if ql in {"who are you","who are you?","what is your name"}:
        return "I’m the VIT Admissions Chatbot."
    if "how do you work" in ql or "how you work" in ql:
        return "I read your SQLite tables first; if it’s a narrative query, I search your PDFs (FAISS or direct PDF text)."
    return None

# ---------- PDF fallback (no FAISS) ----------

def _pdf_text_search(query: str) -> str | None:
    # naive text scan across PDFs for a quick snippet
    import glob, os
    try:
        import PyPDF2  # lightweight
    except Exception:
        return None

    qlow = query.lower()
    tokens = [t for t in qlow.split() if len(t) > 3]
    if not tokens:
        tokens = [qlow]

    for path in glob.glob("Data/**/*.pdf", recursive=True):
        try:
            reader = PyPDF2.PdfReader(path)
            # scan first 30 pages; if nothing, scan rest up to 80
            page_idx = list(range(min(30, len(reader.pages)))) + list(range(30, min(80, len(reader.pages))))
            for i in page_idx:
                try:
                    text = reader.pages[i].extract_text() or ""
                except Exception:
                    continue
                lower = text.lower()
                if any(tok in lower for tok in tokens):
                    # return small clean snippet
                    snippet = " ".join(text.split())
                    snippet = snippet[:900]
                    return f"{snippet}\n\n_Source: {os.path.basename(path)} (p.{i+1})_"
        except Exception:
            continue
    return None

# ---------- RAG & text fallback ----------

def _rag_answer(q: str) -> str | None:
    # FAISS helper A
    try:
        from app.utils.fallback_rag import faiss_answer_or_summary
        from pathlib import Path
        resp = faiss_answer_or_summary(Path("Data/index/faiss"), "vit_faq_vellore", q)
        if resp and resp.strip():
            return resp.strip()
    except Exception:
        pass
    # FAISS helper B
    try:
        from app.utils.fallback_rag import answer as rag_answer
        resp2 = rag_answer(q, max_chunks=6, max_tokens=500)
        if resp2 and resp2.strip():
            return resp2.strip()
    except Exception:
        pass
    # PDF direct search
    pdf = _pdf_text_search(q)
    if pdf:
        return pdf
    return None

# ---------- SQL route ----------

def _sql_route(q: str) -> str | None:
    intent = detect_structured_intent(q)
    f = parse_filters(q)

    if intent == "contacts":   return _pack(sql_block_contacts(f).get("table"))
    if intent == "blocks":     return _pack(sql_list_blocks(f).get("table"))
    if intent == "hostel":     return _pack(sql_hostel_overview(f).get("table"))

    if intent == "programs":     return _pack(sql_programs(f, q).get("table"))
    if intent == "eligibility":  return _pack(sql_eligibility(f, q).get("table"))
    if intent == "documents":    return _pack(sql_documents(f, q).get("table"))
    if intent == "fees":         return _pack(sql_academic_fees(f, q).get("table"))
    if intent == "scholarships": return _pack(sql_scholarships(f, q).get("table"))

    if intent == "links":
        from app.sql_router import sql_links
        return _pack(sql_links(f, q).get("table"))

    return None

# ---------- public ----------

def answer(query: str) -> str:
    # 1) SQL
    sql_text = _sql_route(query)
    if sql_text is not None and sql_text.strip() != "_No matching rows._":
        return sql_text
    # 2) smalltalk
    st = _smalltalk_answer(query)
    if st:
        return st
    # 3) RAG
    rag = _rag_answer(query)
    if rag:
        return rag
    # 4) final
    return "Sorry — I don’t have that yet."

if __name__ == "__main__":
    import argparse, sys
    p = argparse.ArgumentParser()
    p.add_argument("--q", "-q", dest="q", default="")
    p.add_argument("qpos", nargs="*", help="query as positional words")
    args = p.parse_args()
    q = args.q.strip() or " ".join(args.qpos).strip()
    print(answer(q or "UG programs CSE"))
