# app/rag_answer.py
"""
SQL-first router; FAISS fallback; small-talk defaults; no "Try:" tips.
"""

from app.sql_router import (
    detect_structured_intent, parse_filters,
    sql_hostel_overview, sql_block_contacts, sql_list_blocks,
    sql_programs, sql_eligibility, sql_documents, sql_academic_fees, sql_scholarships,  # noqa
)

# ------------------ presentation ------------------

def _fmt_table(tbl: dict) -> str:
    if not tbl or not tbl.get("rows"):
        return "Sorry — I don’t have that in my current tables."
    title  = f"**{tbl.get('title','Results')}**"
    cols   = tbl["columns"]
    header = " | ".join(cols)
    sep    = " | ".join(["---"] * len(cols))
    lines  = [title, "", header, sep]
    for r in tbl["rows"]:
        lines.append(" | ".join("" if x is None else str(x) for x in r))
    return "\n".join(lines)

def _pack(table_dict=None, bullets=None):
    parts = []
    if table_dict: parts.append(_fmt_table(table_dict))
    if bullets:    parts.append("\n".join(f"- {b}" for b in bullets))
    return "\n\n".join(parts) if parts else "Sorry — I don’t have that in my current tables."

# ------------------ smalltalk defaults ------------------

SMALLTALK_ANSWERS = {
    "who": "I’m the **VIT Admissions Chatbot** for your project. I answer from your curated PDFs (FAISS) and your SQLite tables built from CSVs.",
    "what": "I help with VIT admissions info: fees, eligibility, documents, scholarships, programmes, hostel details, and official links.",
    "how": "I first look in your SQLite tables. If not found, I search your FAISS index of PDFs. If nothing matches, I return a short, neutral message.",
    "why": "So students get fast, accurate answers from official data, with PDFs as backup for detailed policies and processes.",
    "when": "I answer instantly using the packaged data (no live web browse).",
    "where": "Data comes from `Data/sql/*.db` and `Data/index/faiss` built from your PDFs."
}

def _is_smalltalk(q: str) -> str | None:
    ql = q.strip().lower()
    if not ql:
        return None
    if any(kw in ql for kw in ["who are you","who r u","your name"]): return "who"
    if any(kw in ql for kw in ["what can you do","what do you do","what can u do","what are you"]): return "what"
    if any(kw in ql for kw in ["how do you work","how it works","how will you work","how you work"]): return "how"
    if ql.startswith("who "): return "who"
    if ql.startswith("what "): return "what"
    if ql.startswith("how "): return "how"
    if ql.startswith("why "): return "why"
    if ql.startswith("when "): return "when"
    if ql.startswith("where "): return "where"
    return None

def _smalltalk_answer(kind: str) -> str:
    return SMALLTALK_ANSWERS.get(kind, "I’m the VIT Admissions Chatbot. Ask me about fees, eligibility, documents, programmes, scholarships, or hostel info.")

# ------------------ SQL routing ------------------

def _sql_route(q: str) -> str | None:
    intent = detect_structured_intent(q)
    f = parse_filters(q)

    # HOSTEL
    if intent == "contacts":   return _pack(sql_block_contacts(f).get("table"))
    if intent == "blocks":     return _pack(sql_list_blocks(f).get("table"))
    if intent in ("hostel","tabular"): return _pack(sql_hostel_overview(f).get("table"))

    # ACADEMICS
    if intent == "programs":     return _pack(sql_programs(f, q).get("table"))
    if intent == "eligibility":  return _pack(sql_eligibility(f, q).get("table"))
    if intent == "documents":    return _pack(sql_documents(f, q).get("table"))
    if intent == "fees":         return _pack(sql_academic_fees(f, q).get("table"))
    if intent == "scholarships": return _pack(sql_scholarships(f, q).get("table"))

    # narrative/links go to RAG outside
    return None

# ------------------ FAISS fallback ------------------

def _rag_answer(q: str) -> str | None:
    # Try both helpers (projects sometimes wire only one)
    try:
        from app.utils.fallback_rag import faiss_answer_or_summary
        from pathlib import Path
        resp = faiss_answer_or_summary(Path("Data/index/faiss"), "vit_faq_vellore", q)
        if resp and resp.strip():
            return resp.strip()
    except Exception:
        pass
    try:
        # legacy helper some repos ship
        from app.utils.fallback_rag import answer as rag_answer
        resp2 = rag_answer(q, max_chunks=6, max_tokens=500)
        if resp2 and resp2.strip():
            return resp2.strip()
    except Exception:
        pass
    return None

# ------------------ public ------------------

def answer(query: str) -> str:
    # 1) smalltalk
    st = _is_smalltalk(query)
    if st:
        return _smalltalk_answer(st)

    # 2) SQL-first
    sql_text = _sql_route(query)
    if sql_text is not None and "Sorry — I don’t have that in my current tables." not in sql_text:
        return sql_text

    # 3) FAISS narrative fallback (application process, refund policy, links if no table, etc.)
    rag = _rag_answer(query)
    if rag:
        return rag

    # 4) final neutral
    return "Sorry — I don’t have that in my current sources."

if __name__ == "__main__":
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument("--q", "-q", dest="q", default="")
    args = p.parse_args()
    print(answer(args.q or "who are you"))
